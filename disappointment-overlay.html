<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Disappointment - Emotional Experience</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f7f7f7;
            font-family: 'Roboto Mono', monospace;
            -webkit-text-size-adjust: 100%;
            touch-action: none;
        }
        
        /* Landing screen that appears first */
        #landing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(247, 247, 247, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            box-sizing: border-box;
            padding: 20px;
            transition: opacity 1s ease-in-out;
        }
        
        .landing-title {
            font-size: 24px;
            font-weight: 500;
            margin-bottom: 40px;
            text-align: center;
            letter-spacing: 1px;
        }
        
        .emotion-name {
            font-size: 36px;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #000000;
        }
        
        .emotion-description {
            font-size: 14px;
            line-height: 1.4;
            max-width: 600px;
            text-align: center;
            margin-bottom: 30px;
            opacity: 0.8;
        }

        .ai-disclaimer {
           font-size: 13px;
           max-width: 550px;
           text-align: center;
           margin-bottom: 40px;
           margin-top: 10px;
           padding: 15px 20px;
           background-color: rgba(0, 0, 0, 0.1);
           border-radius: 8px;
           border-left: 3px solid #000000;
           line-height: 1.6;
           color: #333;
        }
        
        .start-button {
            padding: 15px 35px;
            background-color: rgba(0, 0, 0, 0.2);
            color: #000000;
            border: 1px solid #000000;
            border-radius: 30px;
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
        }
        
        .start-button:active {
            transform: scale(0.98);
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        .disappointment-resonance {
            position: fixed;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 15px;
            max-width: 250px;
            font-size: 13px;
            line-height: 1.4;
            color: #333;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            transform: translateY(20px);
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            pointer-events: none;
            z-index: 100;
            text-align: center;
            border-left: 3px solid #000000;
        }
        
        .controls {
            position: fixed;
            bottom: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .control-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }
        
        .control-button svg {
            width: 20px;
            height: 20px;
            stroke: #000000;
        }
        
        .hint {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background-color: rgba(255, 255, 255, 0.85);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 50;
            color: #000000;
        }
        
        .timeline {
            position: fixed;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            width: 70%;
            max-width: 500px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            z-index: 40;
            opacity: 0;
            transition: opacity 0.5s;
            display: flex;
            align-items: center;
            padding: 0 15px;
        }
        
        .timeline-bar {
            width: 100%;
            height: 4px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
            position: relative;
        }
        
        .timeline-progress {
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            border-radius: 2px;
            width: 0%;
            transition: width 0.3s;
        }
        
        .timeline-handle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #000000;
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }
        
        #loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Roboto Mono', monospace;
            z-index: 10000;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        @media (max-width: 768px) {
            body {
                overflow-y: auto !important;
                height: auto !important;
            }
        
            #landing-overlay {
                position: absolute;
                height: auto;
                min-height: 100%;
                overflow-y: auto;
                padding: 40px 20px 120px 20px;
                justify-content: flex-start;
            }
        
            .landing-title {
                margin-top: 40px;
            }
        
            .start-button {
                margin-bottom: 60px;
                position: relative;
            }
        
            .emotion-name {
                font-size: 42px;
            }
        
            .ai-disclaimer {
                width: 90%;
                font-size: 12px;
                max-width: 90%;
            }
        }
        
        @media screen and (orientation: portrait) {
            .controls {
                bottom: 70px;
                right: 15px;
            }
            
            .timeline {
                bottom: 20px;
                width: 80%;
            }
        }
        
        @media screen and (orientation: landscape) {
            .controls {
                bottom: 15px;
                right: 100px;
            }
            
            .timeline {
                bottom: 20px;
                width: 60%;
                max-width: 600px;
            }
        }
    </style>
</head>
<body>
    <div id="loading-indicator">Loading experience...</div>
    
    <div id="landing-overlay">
        <h1 class="landing-title">Emotional Collage Experience</h1>
        <h2 class="emotion-name" id="emotion-title">DISAPPOINTMENT</h2>
        <p class="emotion-description" id="emotion-description">
            An exploration of disappointment as the interruption of expectations, creating fractured pathways between hope and reality.
            <br><b>Analysis by Claude</b>
        </p>

        <div class="ai-disclaimer">
            <strong>Note:</strong> This is a simulation of disappointment based on my analysis of human descriptions. As an AI, I don't experience emotions or feelings - this is just my interpretation of a human concept.
        </div>
        
        <button class="start-button" id="start-experience">Begin Experience</button>
    </div>
    
    <div class="disappointment-resonance" id="disappointment-resonance"></div>
    
    <div class="controls" id="controls">
        <div class="control-button" id="sound-toggle">
            <svg viewBox="0 0 24 24" fill="none" stroke-width="2">
                <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                <path id="sound-waves" d="M15.54 8.46a5 5 0 0 1 0 7.07M19.07 4.93a10 10 0 0 1 0 14.14"></path>
            </svg>
        </div>
        <div class="control-button" id="reset-button">
            <svg viewBox="0 0 24 24" fill="none" stroke-width="2">
                <path d="M23 4v6h-6"></path>
                <path d="M1 20v-6h6"></path>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
        </div>
    </div>
    
    <div class="hint" id="hint">Touch elements to explore disappointment</div>
    
    <div class="timeline" id="timeline">
        <div class="timeline-bar" id="timeline-bar">
            <div class="timeline-progress" id="timeline-progress"></div>
            <div class="timeline-handle" id="timeline-handle"></div>
        </div>
    </div>
    
    <script>
        // Performance optimizations
        let frameworkElements = [];
        let disruptionElements = [];
        let highlightElements = [];
        let connectionLines = [];
        let handOutlinePoints = [];
        let disappointmentCenters = [];
        
        // Cache frequently used calculations
        let sinCache = {};
        let cosCache = {};
        const CACHE_PRECISION = 1000;
        
        // Precompute sin/cos for common angles
        function precomputeTrig() {
            for (let i = 0; i < CACHE_PRECISION; i++) {
                let angle = (i / CACHE_PRECISION) * TWO_PI;
                sinCache[i] = sin(angle);
                cosCache[i] = cos(angle);
            }
        }
        
        function fastSin(angle) {
            let normalized = ((angle % TWO_PI) + TWO_PI) % TWO_PI;
            let index = Math.floor((normalized / TWO_PI) * CACHE_PRECISION);
            return sinCache[index] || sin(angle);
        }
        
        function fastCos(angle) {
            let normalized = ((angle % TWO_PI) + TWO_PI) % TWO_PI;
            let index = Math.floor((normalized / TWO_PI) * CACHE_PRECISION);
            return cosCache[index] || cos(angle);
        }
        
        // Core variables
        let isAnimating = true;
        let soundEnabled = true;
        let disappointmentSound;
        let soundLoaded = false;
        let soundLoadTimeout;
        let isDraggingTimeline = false;
        let timePosition = 0;
        let previousTimePosition = 0;
        let activatedTimeline = false;
        let tensionPhase = 0;
        let tensionRate = 0.6;
        let resizeTimeout;
        let lastInteractionTime = 0;
        
        let handProgress = 0;
        let activeDisappointmentCenter = null;
        let centerActivated = false;
        
        // Spatial partitioning for optimization
        let elementGrid = {};
        const GRID_SIZE = 150;
        
        function getGridKey(x, y) {
            return `${Math.floor(x / GRID_SIZE)}_${Math.floor(y / GRID_SIZE)}`;
        }
        
        function addToGrid(element, x, y) {
            let key = getGridKey(x, y);
            if (!elementGrid[key]) elementGrid[key] = [];
            elementGrid[key].push(element);
        }
        
        function getNearbyElements(x, y, range = 1) {
            let nearby = [];
            let gx = Math.floor(x / GRID_SIZE);
            let gy = Math.floor(y / GRID_SIZE);
            
            for (let dx = -range; dx <= range; dx++) {
                for (let dy = -range; dy <= range; dy++) {
                    let key = `${gx + dx}_${gy + dy}`;
                    if (elementGrid[key]) {
                        nearby.push(...elementGrid[key]);
                    }
                }
            }
            return nearby;
        }
        
        // Throttle propagation updates
        let propagationFrame = 0;
        const PROPAGATION_SKIP = 2; // Only update every 3rd frame
        
        const disappointmentResonances = [
            "The hollow feeling when expectations meet reality",
            "When anticipated joy collapses into emptiness",
            "The quiet moment when possibilities narrow unexpectedly",
            "The space between what could have been and what is",
            "When a path forward suddenly terminates",
            "The weight of unfulfilled potential",
            "The gradual recognition that things won't turn out as hoped",
            "A sinking sensation as expectations dissolve",
            "The stillness after hopes have been dashed",
            "When the anticipated outcome recedes from reach",
            "The deflation of enthusiasm facing an obstacle",
            "A moment of recognition that plans must change",
            "The abrupt ending to a promising trajectory",
            "When the expected pathway suddenly disappears",
            "The gap between what was promised and what was delivered"
        ];
        
        const colors = {
            black: [0, 0, 0],
            yellow: [255, 204, 0],
            brown: [121, 85, 72]
        };
        
        function startExperience() {
            document.getElementById('landing-overlay').style.opacity = '0';
            
            setTimeout(() => {
                document.getElementById('landing-overlay').style.display = 'none';
                isAnimating = true;
                loop();
                updateLayoutForOrientation();
                
                if (soundEnabled && soundLoaded) {
                    try {
                        disappointmentSound.loop();
                        disappointmentSound.setVolume(0);
                        disappointmentSound.setVolume(0.6, 2);
                    } catch(e) {
                        console.error("Error playing sound:", e);
                    }
                }
                
                setTimeout(() => {
                    document.getElementById('controls').style.opacity = '1';
                    document.getElementById('hint').style.opacity = '1';
                    
                    setTimeout(() => {
                        document.getElementById('hint').style.opacity = '0';
                    }, 5000);
                }, 2000);
            }, 1000);
        }
        
        function updateLayoutForOrientation() {
            const controls = document.getElementById('controls');
            const timeline = document.getElementById('timeline');
            
            if (window.matchMedia("(orientation: portrait)").matches) {
                controls.style.bottom = "70px";
                controls.style.right = "15px";
                timeline.style.width = "80%";
            } else {
                controls.style.bottom = "15px";
                controls.style.right = "100px"; 
                timeline.style.width = "60%";
            }
        }
        
        window.addEventListener('orientationchange', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                resizeCanvas(windowWidth, windowHeight);
                repositionElements();
                updateLayoutForOrientation();
            }, 300);
        });
        
        document.getElementById('start-experience').addEventListener('click', startExperience);
        document.getElementById('start-experience').addEventListener('touchend', function(e) {
            e.preventDefault();
            startExperience();
        });
        
        document.getElementById('sound-toggle').addEventListener('click', function() {
            soundEnabled = !soundEnabled;
            document.getElementById('sound-waves').style.opacity = soundEnabled ? '1' : '0';
            
            if (soundEnabled && disappointmentSound && soundLoaded && !disappointmentSound.isPlaying()) {
                disappointmentSound.loop();
                disappointmentSound.setVolume(0);
                disappointmentSound.setVolume(0.6, 1);
            } else if (!soundEnabled && disappointmentSound && soundLoaded && disappointmentSound.isPlaying()) {
                disappointmentSound.setVolume(0, 1.5);
                setTimeout(() => {
                    if (!soundEnabled && disappointmentSound && disappointmentSound.isPlaying()) {
                        disappointmentSound.pause();
                    }
                }, 1500);
            }
        });
        
        document.getElementById('reset-button').addEventListener('click', function() {
            timePosition = 0;
            previousTimePosition = 0;
            resetExperience();
            updateTimelineUI();
        });
        
        const timelineBar = document.getElementById('timeline-bar');
        timelineBar.addEventListener('mousedown', startTimelineDrag);
        timelineBar.addEventListener('touchstart', function(e) {
            e.preventDefault();
            startTimelineDrag(e);
        });
        
        function startTimelineDrag(e) {
            isDraggingTimeline = true;
            updateTimelinePosition(e);
            document.addEventListener('mousemove', updateTimelinePosition);
            document.addEventListener('touchmove', updateTimelinePosition, { passive: false });
            document.addEventListener('mouseup', endTimelineDrag);
            document.addEventListener('touchend', endTimelineDrag);
        }
        
        function updateTimelinePosition(e) {
            if (!isDraggingTimeline) return;
            
            if (e.type === 'touchmove') {
                e.preventDefault();
            }
            
            const timeline = document.getElementById('timeline-bar');
            const rect = timeline.getBoundingClientRect();
            
            let clientX;
            if (e.type.startsWith('touch')) {
                clientX = e.touches[0].clientX;
            } else {
                clientX = e.clientX;
            }
            
            let percentage = (clientX - rect.left) / rect.width;
            percentage = Math.max(0, Math.min(1, percentage));
            
            document.getElementById('timeline-progress').style.width = `${percentage * 100}%`;
            document.getElementById('timeline-handle').style.left = `${percentage * 100}%`;
            
            timePosition = percentage * 40000;
            setTimePosition(timePosition);
        }
        
        function endTimelineDrag() {
            isDraggingTimeline = false;
            document.removeEventListener('mousemove', updateTimelinePosition);
            document.removeEventListener('touchmove', updateTimelinePosition);
            document.removeEventListener('mouseup', endTimelineDrag);
            document.removeEventListener('touchend', endTimelineDrag);
            previousTimePosition = timePosition;
        }
        
        function updateTimelineUI() {
            const percentage = timePosition / 40000;
            document.getElementById('timeline-progress').style.width = `${percentage * 100}%`;
            document.getElementById('timeline-handle').style.left = `${percentage * 100}%`;
        }
        
        function preload() {
            soundLoaded = false;
            
            try {
                disappointmentSound = loadSound('disappointment_soundscape.mp3', 
                    function() {
                        console.log("Sound loaded successfully");
                        soundLoaded = true;
                        clearTimeout(soundLoadTimeout);
                    },
                    function(err) {
                        console.error("Error loading sound:", err);
                        soundEnabled = false;
                        clearTimeout(soundLoadTimeout);
                    }
                );
                
                soundLoadTimeout = setTimeout(() => {
                    console.log("Sound loading timed out");
                    soundEnabled = false;
                    soundLoaded = false;
                }, 10000);
            } catch(e) {
                console.error("Could not load sound:", e);
                soundEnabled = false;
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            frameRate(30);
            
            // Precompute trig functions
            precomputeTrig();
            
            createHandOutline();
            createFrameworkElements();
            createDisruptionElements();
            createHighlightElements();
            createConnectionLines();
            createDisappointmentCenters();
            
            document.getElementById('loading-indicator').style.display = 'none';
            
            if (getAudioContext().state !== 'running') {
                getAudioContext().resume();
            }
            
            isAnimating = false;
            noLoop();
        }
        
        function getRandomResonance() {
            return disappointmentResonances[Math.floor(random(disappointmentResonances.length))];
        }
        
        function createFrameworkElements() {
            let centerX = width * 0.5;
            let gapStart = centerX - width * 0.05;
            let gapEnd = centerX + width * 0.05;
            
            frameworkElements.push({
                type: 'line',
                x: width * 0.2,
                y: height * 0.5,
                length: gapStart - width * 0.2,
                width: 3,
                angle: 0,
                opacity: 220,
                startTime: 500,
                visible: false,
                interactive: true,
                activated: false,
                activatedTime: 0,
                tension: 0,
                maxTension: 100,
                tensionRate: 0.03,
                pulseRate: 0.0008
            });
            
            frameworkElements.push({
                type: 'line',
                x: gapEnd,
                y: height * 0.5,
                length: width * 0.8 - gapEnd,
                width: 3,
                angle: 0,
                opacity: 220,
                startTime: 800,
                visible: false,
                interactive: true,
                activated: false,
                activatedTime: 0,
                tension: 0,
                maxTension: 100,
                tensionRate: 0.03,
                pulseRate: 0.0008
            });
            
            for (let i = 0; i < 10; i++) {
                let horizontal = i % 2 === 0;
                
                if (horizontal) {
                    let startX = width * 0.2;
                    let startY = height * (0.25 + (i / 20) * 0.5);
                    let interruptPos = random(0.3, 0.7);
                    let interruptWidth = random(0.03, 0.08);
                    
                    frameworkElements.push({
                        type: 'line',
                        x: startX,
                        y: startY,
                        length: width * (interruptPos - interruptWidth/2) - startX,
                        width: random(1, 2.5),
                        angle: 0,
                        opacity: random(160, 220),
                        startTime: 1000 + i * 400,
                        visible: false,
                        interactive: random() > 0.4,
                        activated: false,
                        activatedTime: 0,
                        tension: 0,
                        maxTension: random(70, 100),
                        tensionRate: random(0.01, 0.04),
                        pulseRate: random(0.0006, 0.001)
                    });
                    
                    frameworkElements.push({
                        type: 'line',
                        x: width * (interruptPos + interruptWidth/2),
                        y: startY,
                        length: width * 0.8 - width * (interruptPos + interruptWidth/2),
                        width: random(1, 2.5),
                        angle: 0,
                        opacity: random(140, 200),
                        startTime: 1000 + i * 400 + 300,
                        visible: false,
                        interactive: random() > 0.4,
                        activated: false,
                        activatedTime: 0,
                        tension: 0,
                        maxTension: random(60, 90),
                        tensionRate: random(0.01, 0.03),
                        pulseRate: random(0.0006, 0.001)
                    });
                } else {
                    let startX = width * (0.25 + (i / 20) * 0.5);
                    let startY = height * 0.2;
                    let interruptPos = random(0.3, 0.7);
                    let interruptWidth = random(0.03, 0.08);
                    
                    frameworkElements.push({
                        type: 'line',
                        x: startX,
                        y: startY,
                        length: height * (interruptPos - interruptWidth/2) - startY,
                        width: random(1, 2.5),
                        angle: HALF_PI,
                        opacity: random(160, 220),
                        startTime: 1500 + i * 400,
                        visible: false,
                        interactive: random() > 0.4,
                        activated: false,
                        activatedTime: 0,
                        tension: 0,
                        maxTension: random(70, 100),
                        tensionRate: random(0.01, 0.04),
                        pulseRate: random(0.0006, 0.001)
                    });
                    
                    frameworkElements.push({
                        type: 'line',
                        x: startX,
                        y: height * (interruptPos + interruptWidth/2),
                        length: height * 0.8 - height * (interruptPos + interruptWidth/2),
                        width: random(1, 2.5),
                        angle: HALF_PI,
                        opacity: random(140, 200),
                        startTime: 1500 + i * 400 + 300,
                        visible: false,
                        interactive: random() > 0.4,
                        activated: false,
                        activatedTime: 0,
                        tension: 0,
                        maxTension: random(60, 90),
                        tensionRate: random(0.01, 0.03),
                        pulseRate: random(0.0006, 0.001)
                    });
                }
            }
            
            for (let i = 0; i < 6; i++) {
                frameworkElements.push({
                    type: 'dots',
                    x: width * (0.3 + random(0.4)),
                    y: height * (0.3 + random(0.4)),
                    size: random(50, 100),
                    dotSize: random(1.5, 3),
                    spacing: random(7, 14),
                    angle: random(TWO_PI),
                    opacity: random(140, 200),
                    startTime: 3000 + i * 600,
                    visible: false,
                    interactive: random() > 0.3,
                    activated: false,
                    activatedTime: 0,
                    tension: 0,
                    maxTension: random(60, 100),
                    tensionRate: random(0.015, 0.04),
                    pulseRate: random(0.0007, 0.001)
                });
            }
            
            for (let i = 0; i < 4; i++) {
                frameworkElements.push({
                    type: 'container',
                    x: width * (0.25 + random(0.5)),
                    y: height * (0.25 + random(0.5)),
                    width: random(80, 150),
                    height: random(80, 150),
                    shape: random() > 0.5 ? 'rect' : 'ellipse',
                    strokeWeight: random(1.5, 2.5),
                    opacity: random(120, 180),
                    startTime: 5000 + i * 800,
                    visible: false,
                    interactive: true,
                    activated: false,
                    activatedTime: 0,
                    tension: 0,
                    maxTension: random(70, 100),
                    tensionRate: random(0.02, 0.04),
                    pulseRate: random(0.0006, 0.001)
                });
            }
        }
        
        function createDisruptionElements() {
            for (let i = 0; i < 6; i++) {
                disruptionElements.push({
                    type: 'triangle',
                    x: width * (0.3 + random(0.4)),
                    y: height * (0.3 + random(0.4)),
                    size: random(15, 30),
                    rotation: random(TWO_PI),
                    opacity: random(180, 220),
                    startTime: 7000 + i * 800,
                    visible: false,
                    interactive: true,
                    activated: false,
                    activatedTime: 0,
                    intensity: 0,
                    maxIntensity: random(80, 100),
                    intensityRate: random(0.02, 0.05),
                    pulseRate: random(0.001, 0.003)
                });
            }
            
            for (let i = 0; i < 4; i++) {
                disruptionElements.push({
                    type: 'block',
                    x: width * (0.3 + random(0.4)),
                    y: height * (0.3 + random(0.4)),
                    width: random(20, 40),
                    height: random(20, 40),
                    rotation: random(PI/4),
                    opacity: random(170, 210),
                    startTime: 9000 + i * 1000,
                    visible: false,
                    interactive: true,
                    activated: false,
                    activatedTime: 0,
                    intensity: 0,
                    maxIntensity: random(80, 100),
                    intensityRate: random(0.02, 0.05),
                    pulseRate: random(0.001, 0.0025)
                });
            }
            
            for (let i = 0; i < 3; i++) {
                disruptionElements.push({
                    type: 'alert',
                    x: width * (0.3 + random(0.4)),
                    y: height * (0.3 + random(0.4)),
                    size: random(25, 40),
                    opacity: random(160, 210),
                    startTime: 11000 + i * 1200,
                    visible: false,
                    interactive: true,
                    activated: false,
                    activatedTime: 0,
                    intensity: 0,
                    maxIntensity: random(80, 100),
                    intensityRate: random(0.02, 0.05),
                    pulseRate: random(0.001, 0.003),
                    phase: random(TWO_PI)
                });
            }
        }
        
        function createHighlightElements() {
            for (let i = 0; i < 5; i++) {
                highlightElements.push({
                    type: 'platform',
                    x: width * (0.25 + random(0.5)),
                    y: height * (0.6 + random(0.25)),
                    width: random(60, 120),
                    height: random(8, 15),
                    opacity: random(160, 200),
                    startTime: 13000 + i * 800,
                    visible: false,
                    interactive: random() > 0.3,
                    activated: false,
                    activatedTime: 0,
                    energy: 0,
                    maxEnergy: random(70, 90),
                    energyRate: random(0.02, 0.04),
                    pulseRate: random(0.0008, 0.0015)
                });
            }
            
            for (let i = 0; i < 4; i++) {
                highlightElements.push({
                    type: 'organic',
                    x: width * (0.3 + random(0.4)),
                    y: height * (0.3 + random(0.4)),
                    size: random(30, 60),
                    points: floor(random(5, 9)),
                    opacity: random(150, 190),
                    startTime: 15000 + i * 1000,
                    visible: false,
                    interactive: true,
                    activated: false,
                    activatedTime: 0,
                    energy: 0,
                    maxEnergy: random(70, 90),
                    energyRate: random(0.02, 0.04),
                    pulseRate: random(0.0008, 0.0015),
                    rotation: random(TWO_PI),
                    noiseScale: random(0.3, 0.7)
                });
            }
            
            for (let i = 0; i < 3; i++) {
                let startX = width * (0.35 + random(0.1));
                let startY = height * (0.4 + random(0.2));
                let endX = width * (0.55 + random(0.1));
                let endY = height * (0.4 + random(0.2));
                
                let points = [];
                points.push({x: startX, y: startY});
                
                let controlX1 = lerp(startX, endX, 0.3) + random(-30, 30);
                let controlY1 = lerp(startY, endY, 0.3) + random(-30, 30);
                let controlX2 = lerp(startX, endX, 0.7) + random(-30, 30);
                let controlY2 = lerp(startY, endY, 0.7) + random(-30, 30);
                
                points.push({x: controlX1, y: controlY1});
                points.push({x: controlX2, y: controlY2});
                points.push({x: endX, y: endY});
                
                highlightElements.push({
                    type: 'path',
                    points: points,
                    width: random(2, 3),
                    dashArray: [random(4, 8), random(6, 12)],
                    opacity: random(150, 190),
                    startTime: 17000 + i * 1200,
                    visible: false,
                    interactive: true,
                    activated: false,
                    activatedTime: 0,
                    energy: 0,
                    maxEnergy: random(70, 90),
                    energyRate: random(0.02, 0.04),
                    pulseRate: random(0.0008, 0.0015),
                    progress: 0
                });
            }
        }
        
        function createConnectionLines() {
            for (let i = 0; i < frameworkElements.length; i++) {
                let framework = frameworkElements[i];
                
                for (let j = 0; j < disruptionElements.length; j++) {
                    let disruption = disruptionElements[j];
                    let d = dist(framework.x, framework.y, disruption.x, disruption.y);
                    
                    if (d < 180 && random() > 0.7) {
                        connectionLines.push({
                            startElement: 'framework',
                            startIndex: i,
                            endElement: 'disruption',
                            endIndex: j,
                            opacity: random(100, 160),
                            dotSize: random(1.5, 2.5),
                            dotSpacing: random(10, 15),
                            progress: 0,
                            startTime: max(framework.startTime, disruption.startTime) + 1000,
                            activated: false,
                            broken: random() > 0.5
                        });
                    }
                }
                
                for (let j = 0; j < highlightElements.length; j++) {
                    let highlight = highlightElements[j];
                    
                    if (highlight.type !== 'path') {
                        let d = dist(framework.x, framework.y, highlight.x, highlight.y);
                        
                        if (d < 200 && random() > 0.7) {
                            connectionLines.push({
                                startElement: 'framework',
                                startIndex: i,
                                endElement: 'highlight',
                                endIndex: j,
                                opacity: random(90, 140),
                                dotSize: random(1.5, 2.5),
                                dotSpacing: random(10, 15),
                                progress: 0,
                                startTime: max(framework.startTime, highlight.startTime) + 1200,
                                activated: false,
                                broken: random() > 0.4
                            });
                        }
                    }
                }
            }
            
            for (let i = 0; i < disruptionElements.length; i++) {
                let disruption = disruptionElements[i];
                
                for (let j = 0; j < highlightElements.length; j++) {
                    let highlight = highlightElements[j];
                    
                    if (highlight.type !== 'path') {
                        let d = dist(disruption.x, disruption.y, highlight.x, highlight.y);
                        
                        if (d < 220 && random() > 0.5) {
                            connectionLines.push({
                                startElement: 'disruption',
                                startIndex: i,
                                endElement: 'highlight',
                                endIndex: j,
                                opacity: random(100, 160),
                                dotSize: random(1.5, 2.5),
                                dotSpacing: random(8, 12),
                                progress: 0,
                                startTime: max(disruption.startTime, highlight.startTime) + 1400,
                                activated: false,
                                broken: random() > 0.7
                            });
                        }
                    }
                }
            }
        }

        function createHandOutline() {
            handOutlinePoints.push({x: 0.52, y: 0.65});
            handOutlinePoints.push({x: 0.62, y: 0.65});
            handOutlinePoints.push({x: 0.65, y: 0.60});
            handOutlinePoints.push({x: 0.64, y: 0.55});
            handOutlinePoints.push({x: 0.63, y: 0.50});
            handOutlinePoints.push({x: 0.61, y: 0.46});
            handOutlinePoints.push({x: 0.59, y: 0.43});
            handOutlinePoints.push({x: 0.56, y: 0.41});
            handOutlinePoints.push({x: 0.52, y: 0.40});
            handOutlinePoints.push({x: 0.48, y: 0.41});
            handOutlinePoints.push({x: 0.45, y: 0.43});
            handOutlinePoints.push({x: 0.43, y: 0.46});
            handOutlinePoints.push({x: 0.41, y: 0.50});
            handOutlinePoints.push({x: 0.42, y: 0.55});
            handOutlinePoints.push({x: 0.43, y: 0.60});
            handOutlinePoints.push({x: 0.52, y: 0.65});
            
            for (let i = 0; i < handOutlinePoints.length; i++) {
                handOutlinePoints[i].x *= width;
                handOutlinePoints[i].y *= height;
            }
        }
        
        function createDisappointmentCenters() {
            disappointmentCenters.push({
                x: width * 0.5, 
                y: height * 0.5,
                size: 80,
                opacity: 0,
                targetOpacity: 180,
                pulseRate: 0.0015,
                activated: false,
                activationProgress: 0,
                startTime: 20000,
                resonance: "The hollow space where expectation meets reality",
                elements: []
            });
            
            for (let i = 0; i < 2; i++) {
                disappointmentCenters.push({
                    x: random(width * 0.3, width * 0.7),
                    y: random(height * 0.3, height * 0.7),
                    size: random(50, 70),
                    opacity: 0,
                    targetOpacity: random(150, 200),
                    pulseRate: random(0.001, 0.002),
                    activated: false,
                    activationProgress: 0,
                    startTime: 24000 + i * 4000,
                    resonance: getRandomResonance(),
                    elements: []
                });
            }
            
            for (let i = 0; i < frameworkElements.length; i++) {
                let framework = frameworkElements[i];
                let closestCenter = null;
                let closestDistance = Infinity;
                
                for (let j = 0; j < disappointmentCenters.length; j++) {
                    let d = dist(framework.x, framework.y, disappointmentCenters[j].x, disappointmentCenters[j].y);
                    if (d < closestDistance && d < 200) {
                        closestDistance = d;
                        closestCenter = j;
                    }
                }
                
                if (closestCenter !== null) {
                    disappointmentCenters[closestCenter].elements.push({
                        type: 'framework',
                        index: i
                    });
                }
            }
            
            for (let i = 0; i < disruptionElements.length; i++) {
                let disruption = disruptionElements[i];
                let closestCenter = null;
                let closestDistance = Infinity;
                
                for (let j = 0; j < disappointmentCenters.length; j++) {
                    let d = dist(disruption.x, disruption.y, disappointmentCenters[j].x, disappointmentCenters[j].y);
                    if (d < closestDistance && d < 170) {
                        closestDistance = d;
                        closestCenter = j;
                    }
                }
                
                if (closestCenter !== null) {
                    disappointmentCenters[closestCenter].elements.push({
                        type: 'disruption',
                        index: i
                    });
                }
            }
            
            for (let i = 0; i < highlightElements.length; i++) {
                let highlight = highlightElements[i];
                
                if (highlight.type !== 'path') {
                    let closestCenter = null;
                    let closestDistance = Infinity;
                    
                    for (let j = 0; j < disappointmentCenters.length; j++) {
                        let d = dist(highlight.x, highlight.y, disappointmentCenters[j].x, disappointmentCenters[j].y);
                        if (d < closestDistance && d < 180) {
                            closestDistance = d;
                            closestCenter = j;
                        }
                    }
                    
                    if (closestCenter !== null) {
                        disappointmentCenters[closestCenter].elements.push({
                            type: 'highlight',
                            index: i
                        });
                    }
                }
            }
        }

        function draw() {
            background(247, 247, 247);
            
            if (isAnimating && !isDraggingTimeline) {
                timePosition += deltaTime * 0.8;
                
                if (timePosition > 40000) {
                    timePosition = 40000;
                    
                    if (!activatedTimeline) {
                        showTimeline();
                        activatedTimeline = true;
                    }
                }
                
                updateTimelineUI();
                previousTimePosition = timePosition;
            }

            tensionPhase += tensionRate * deltaTime * 0.0008;
            
            drawFrameworkElements();
            drawConnectionLines();
            drawDisruptionElements();
            drawHighlightElements();
            drawHandOutline();
            drawDisappointmentCenters();
            
            if (isAnimating) {
                handProgress = min(1, handProgress + 0.0003);
            }
            
            updateActivatedElements();
            
            // Throttled propagation
            propagationFrame++;
            if (propagationFrame % PROPAGATION_SKIP === 0) {
                updateElementPropagation();
            }
        }
        
        function showTimeline() {
            document.getElementById('timeline').style.opacity = '1';
            updateLayoutForOrientation();
        }
        
        function updateActivatedElements() {
            for (let framework of frameworkElements) {
                if (framework.activated) {
                    if (framework.tension > 0) {
                        framework.tension = max(0, framework.tension - 0.3);
                    }
                    
                    if (millis() - framework.activatedTime > 4000) {
                        framework.activated = false;
                    }
                }
            }
            
            for (let disruption of disruptionElements) {
                if (disruption.activated) {
                    if (disruption.intensity > 0) {
                        disruption.intensity = max(0, disruption.intensity - 0.4);
                    }
                    
                    if (millis() - disruption.activatedTime > 4000) {
                        disruption.activated = false;
                    }
                }
            }
            
            for (let highlight of highlightElements) {
                if (highlight.activated) {
                    if (highlight.energy > 0) {
                        highlight.energy = max(0, highlight.energy - 0.35);
                    }
                    
                    if (millis() - highlight.activatedTime > 4000) {
                        highlight.activated = false;
                    }
                }
            }
            
            for (let center of disappointmentCenters) {
                if (center.activated) {
                    center.activationProgress = min(1, center.activationProgress + 0.008);
                }
            }
            
            if (activeDisappointmentCenter !== null && !disappointmentCenters[activeDisappointmentCenter].activated) {
                if (disappointmentCenters[activeDisappointmentCenter].activationProgress > 0) {
                    disappointmentCenters[activeDisappointmentCenter].activationProgress = max(0, disappointmentCenters[activeDisappointmentCenter].activationProgress - 0.015);
                } else {
                    activeDisappointmentCenter = null;
                    centerActivated = false;
                }
            }
        }
        
        function updateElementPropagation() {
            // Only check activated elements for performance
            for (let i = 0; i < frameworkElements.length; i++) {
                let framework = frameworkElements[i];
                
                if (framework.activated && framework.tension > 30) {
                    for (let j = 0; j < disruptionElements.length; j++) {
                        let disruption = disruptionElements[j];
                        let d = dist(framework.x, framework.y, disruption.x, disruption.y);
                        
                        if (d < 180) {
                            let intensityTransfer = max(0, framework.tension * (1 - d/180) * 0.15);
                            disruption.intensity = min(disruption.maxIntensity, disruption.intensity + intensityTransfer);
                            
                            if (disruption.intensity > 25 && !disruption.activated) {
                                disruption.activated = true;
                                disruption.activatedTime = millis();
                            }
                        }
                    }
                }
            }
            
            for (let i = 0; i < disruptionElements.length; i++) {
                let disruption = disruptionElements[i];
                
                if (disruption.activated && disruption.intensity > 35) {
                    for (let j = 0; j < highlightElements.length; j++) {
                        let highlight = highlightElements[j];
                        
                        if (highlight.type !== 'path') {
                            let d = dist(disruption.x, disruption.y, highlight.x, highlight.y);
                            
                            if (d < 200) {
                                let energyTransfer = max(0, disruption.intensity * (1 - d/200) * 0.12);
                                highlight.energy = min(highlight.maxEnergy, highlight.energy + energyTransfer);
                                
                                if (highlight.energy > 30 && !highlight.activated) {
                                    highlight.activated = true;
                                    highlight.activatedTime = millis();
                                }
                            }
                        }
                    }
                }
            }
            
            for (let i = 0; i < highlightElements.length; i++) {
                let highlight = highlightElements[i];
                
                if (highlight.activated && highlight.energy > 50) {
                    let energyValue = highlight.energy;
                    
                    for (let j = 0; j < frameworkElements.length; j++) {
                        let framework = frameworkElements[j];
                        let d = dist(highlight.x, highlight.y, framework.x, framework.y);
                        
                        if (d < 180) {
                            let tensionTransfer = max(0, energyValue * (1 - d/180) * 0.06);
                            framework.tension = min(framework.maxTension, framework.tension + tensionTransfer);
                            
                            if (framework.tension > 30 && !framework.activated) {
                                framework.activated = true;
                                framework.activatedTime = millis();
                            }
                        }
                    }
                }
            }
        }
        
        function setTimePosition(time) {
            const previousMillis = previousTimePosition;
            const timeDiff = time - previousMillis;
            
            if (timeDiff < -2000) {
                resetExperience();
            }
        }
        
        function resetExperience() {
            for (let framework of frameworkElements) {
                framework.visible = timePosition > framework.startTime;
                framework.activated = false;
                framework.tension = 0;
            }
            
            for (let disruption of disruptionElements) {
                disruption.visible = timePosition > disruption.startTime;
                disruption.activated = false;
                disruption.intensity = 0;
            }
            
            for (let highlight of highlightElements) {
                highlight.visible = timePosition > highlight.startTime;
                highlight.activated = false;
                highlight.energy = 0;
                
                if (highlight.type === 'path') {
                    highlight.progress = 0;
                }
            }
            
            for (let line of connectionLines) {
                line.progress = timePosition > line.startTime ? 1 : 0;
                line.activated = false;
            }
            
            for (let center of disappointmentCenters) {
                center.opacity = timePosition > center.startTime ? center.targetOpacity : 0;
                center.activated = false;
                center.activationProgress = 0;
            }
            
            handProgress = min(1, timePosition / 25000);
            activeDisappointmentCenter = null;
            centerActivated = false;
        }

        function drawHandOutline() {
            if (timePosition < 12000) return;
            
            let pointsToShow = floor(handOutlinePoints.length * handProgress);
            if (pointsToShow < 2) return;
            
            noFill();
            stroke(0, 0, 0, 120);
            strokeWeight(1.5);
            
            beginShape();
            for (let i = 0; i < pointsToShow; i++) {
                vertex(handOutlinePoints[i].x, handOutlinePoints[i].y);
            }
            endShape(pointsToShow === handOutlinePoints.length ? CLOSE : OPEN);
            
            if (pointsToShow === handOutlinePoints.length) {
                stroke(0, 0, 0, 90);
                strokeWeight(1);
                
                beginShape();
                noFill();
                let heartY = (handOutlinePoints[0].y + handOutlinePoints[15].y) / 2 - 5;
                curveVertex(handOutlinePoints[0].x, heartY);
                curveVertex(handOutlinePoints[0].x + 5, heartY);
                curveVertex(handOutlinePoints[7].x, heartY + 5);
                curveVertex(handOutlinePoints[14].x - 5, heartY);
                curveVertex(handOutlinePoints[14].x, heartY);
                endShape();
                
                beginShape();
                noFill();
                curveVertex(handOutlinePoints[15].x - 10, handOutlinePoints[15].y - 15);
                curveVertex(handOutlinePoints[15].x - 5, handOutlinePoints[15].y - 25);
                curveVertex(handOutlinePoints[11].x + 5, handOutlinePoints[11].y + 10);
                curveVertex(handOutlinePoints[11].x + 10, handOutlinePoints[11].y + 20);
                endShape();
                
                if (activeDisappointmentCenter !== null && disappointmentCenters[activeDisappointmentCenter].activationProgress > 0.5) {
                    let centerX = (handOutlinePoints[0].x + handOutlinePoints[7].x) / 2;
                    let centerY = (handOutlinePoints[0].y + handOutlinePoints[7].y) / 2;
                    
                    push();
                    translate(centerX, centerY);
                    
                    noFill();
                    stroke(0, 0, 0, 150 * disappointmentCenters[activeDisappointmentCenter].activationProgress);
                    strokeWeight(1.5);
                    
                    let radius = 12 * disappointmentCenters[activeDisappointmentCenter].activationProgress;
                    let segments = 5;
                    
                    for (let i = 0; i < segments; i++) {
                        let startAngle = TWO_PI * i / segments;
                        let endAngle = TWO_PI * (i + 0.7) / segments;
                        arc(0, 0, radius * 2, radius * 2, startAngle, endAngle);
                    }
                    
                    stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                          170 * disappointmentCenters[activeDisappointmentCenter].activationProgress);
                    strokeWeight(1.5);
                    
                    let lineLength = radius * 1.5;
                    let segments2 = 3;
                    let segmentLength = lineLength * 2 / (segments2 * 2 - 1);
                    
                    for (let i = 0; i < segments2; i++) {
                        let startX = -lineLength + i * segmentLength * 2;
                        line(startX, 0, startX + segmentLength, 0);
                    }
                    
                    fill(colors.brown[0], colors.brown[1], colors.brown[2], 
                        160 * disappointmentCenters[activeDisappointmentCenter].activationProgress);
                    noStroke();
                    ellipse(0, radius * 0.7, 4, 4);
                    
                    pop();
                }
            }
        }
        
        function drawFrameworkElements() {
            for (let i = 0; i < frameworkElements.length; i++) {
                let framework = frameworkElements[i];
                
                if (timePosition > framework.startTime) {
                    framework.visible = true;
                }
                
                if (!framework.visible) continue;
                
                let undulationAmount = fastSin(millis() * framework.pulseRate) * 0.1;
                let tensionFactor = 0;
                
                if (framework.activated || framework.tension > 0) {
                    tensionFactor = framework.tension / framework.maxTension;
                    
                    noFill();
                    stroke(0, 0, 0, 60 * tensionFactor);
                    strokeWeight(1.5);
                    
                    if (framework.type === 'line') {
                        push();
                        translate(framework.x, framework.y);
                        rotate(framework.angle);
                        let glowLength = framework.length * (1 + tensionFactor * 0.08);
                        line(0, 0, glowLength, 0);
                        pop();
                    } else if (framework.type === 'dots') {
                        ellipse(framework.x, framework.y, framework.size + 12 * tensionFactor);
                    } else if (framework.type === 'container') {
                        if (framework.shape === 'rect') {
                            rect(framework.x - framework.width/2 - 5 * tensionFactor, 
                                 framework.y - framework.height/2 - 5 * tensionFactor,
                                 framework.width + 10 * tensionFactor, 
                                 framework.height + 10 * tensionFactor);
                        } else {
                            ellipse(framework.x, framework.y, 
                                   framework.width + 10 * tensionFactor, 
                                   framework.height + 10 * tensionFactor);
                        }
                    }
                }
                
                if (framework.type === 'line') {
                    drawFrameworkLine(framework, undulationAmount, tensionFactor);
                } else if (framework.type === 'dots') {
                    drawDotPattern(framework, undulationAmount, tensionFactor);
                } else if (framework.type === 'container') {
                    drawContainer(framework, undulationAmount, tensionFactor);
                }
                
                if (framework.interactive && !framework.activated) {
                    noFill();
                    stroke(0, 0, 0, 30);
                    strokeWeight(0.8);
                    
                    if (framework.type === 'line') {
                        let midX = framework.x + cos(framework.angle) * framework.length/2;
                        let midY = framework.y + sin(framework.angle) * framework.length/2;
                        ellipse(midX, midY, 12 + sin(millis() * 0.001) * 3, 12 + sin(millis() * 0.001) * 3);
                    } else {
                        ellipse(framework.x, framework.y, 
                               framework.type === 'container' ? framework.width * 0.5 : framework.size * 0.5 + 
                               sin(millis() * 0.001) * 3,
                               framework.type === 'container' ? framework.height * 0.5 : framework.size * 0.5 + 
                               sin(millis() * 0.001) * 3);
                    }
                }
            }
        }
        
        function drawFrameworkLine(framework, undulationAmount, tensionFactor) {
            if (framework.activated || framework.tension > 0) {
                stroke(0, 0, 0, framework.opacity * (0.7 + tensionFactor * 0.3));
            } else {
                stroke(0, 0, 0, framework.opacity);
            }
            
            strokeWeight(framework.width + (framework.activated ? tensionFactor * 1.5 : 0));
            
            push();
            translate(framework.x, framework.y);
            rotate(framework.angle);
            
            if (tensionFactor > 0.3) {
                beginShape();
                noFill();
                
                let segments = 20;
                let waveAmplitude = tensionFactor * 2;
                
                for (let i = 0; i <= segments; i++) {
                    let x = i * framework.length / segments;
                    let y = sin(i * 0.5 + millis() * 0.002) * waveAmplitude;
                    vertex(x, y);
                }
                endShape();
            } else {
                line(0, 0, framework.length, 0);
            }
            
            pop();
        }
        
        function drawDotPattern(framework, undulationAmount, tensionFactor) {
            if (framework.activated || framework.tension > 0) {
                fill(0, 0, 0, framework.opacity * (0.7 + tensionFactor * 0.3));
            } else {
                fill(0, 0, 0, framework.opacity);
            }
            
            noStroke();
            
            push();
            translate(framework.x, framework.y);
            rotate(framework.angle);
            
            let numDots = floor(framework.size / framework.spacing);
            let tension = tensionFactor * 4;
            
            for (let i = -numDots/2; i <= numDots/2; i++) {
                for (let j = -numDots/2; j <= numDots/2; j++) {
                    let x = i * framework.spacing;
                    let y = j * framework.spacing;
                    
                    if (dist(0, 0, x, y) > framework.size/2) continue;
                    
                    if (tensionFactor > 0.3) {
                        let d = dist(0, 0, x, y);
                        let pull = map(d, 0, framework.size/2, 0, tension);
                        let angle = atan2(y, x);
                        x += cos(angle) * pull;
                        y += sin(angle) * pull;
                    }
                    
                    let dotSize = framework.dotSize * (1 + (tensionFactor > 0.3 ? sin(dist(0, 0, x, y) * 0.1 + millis() * 0.001) * 0.2 : 0));
                    ellipse(x, y, dotSize, dotSize);
                }
            }
            
            pop();
        }
        
        function drawContainer(framework, undulationAmount, tensionFactor) {
            noFill();
            
            if (framework.activated || framework.tension > 0) {
                stroke(0, 0, 0, framework.opacity * (0.7 + tensionFactor * 0.3));
            } else {
                stroke(0, 0, 0, framework.opacity);
            }
            
            strokeWeight(framework.strokeWeight + (framework.activated ? tensionFactor * 1 : 0));
            
            push();
            translate(framework.x, framework.y);
            
            if (tensionFactor > 0.3) {
                let distortAmount = tensionFactor * 0.1;
                let topOffset = sin(millis() * 0.0015) * framework.width * distortAmount;
                let rightOffset = sin(millis() * 0.0015 + 1) * framework.height * distortAmount;
                let bottomOffset = sin(millis() * 0.0015 + 2) * framework.width * distortAmount;
                let leftOffset = sin(millis() * 0.0015 + 3) * framework.height * distortAmount;
                
                if (framework.shape === 'rect') {
                    beginShape();
                    vertex(-framework.width/2 + leftOffset, -framework.height/2);
                    vertex(framework.width/2, -framework.height/2 + topOffset);
                    vertex(framework.width/2 - rightOffset, framework.height/2);
                    vertex(-framework.width/2, framework.height/2 - bottomOffset);
                    endShape(CLOSE);
                } else {
                    beginShape();
                    let steps = 24;
                    for (let i = 0; i < steps; i++) {
                        let angle = TWO_PI * i / steps;
                        let r = 1 + sin(angle * 3 + millis() * 0.001) * distortAmount;
                        let x = cos(angle) * framework.width/2 * r;
                        let y = sin(angle) * framework.height/2 * r;
                        vertex(x, y);
                    }
                    endShape(CLOSE);
                }
            } else {
                if (framework.shape === 'rect') {
                    rect(-framework.width/2, -framework.height/2, framework.width, framework.height);
                } else {
                    ellipse(0, 0, framework.width, framework.height);
                }
            }
            
            pop();
        }

        function drawDisruptionElements() {
            for (let i = 0; i < disruptionElements.length; i++) {
                let disruption = disruptionElements[i];
                
                if (timePosition > disruption.startTime) {
                    disruption.visible = true;
                }
                
                if (!disruption.visible) continue;
                
                if (disruption.type === 'triangle') {
                    drawTriangleElement(disruption);
                } else if (disruption.type === 'block') {
                    drawBlockElement(disruption);
                } else if (disruption.type === 'alert') {
                    drawAlertElement(disruption);
                }
            }
        }
        
        function drawTriangleElement(disruption) {
            let intensityFactor = 0;
            if (disruption.activated || disruption.intensity > 0) {
                intensityFactor = disruption.intensity / disruption.maxIntensity;
            }
            
            push();
            translate(disruption.x, disruption.y);
            rotate(disruption.rotation + (intensityFactor > 0 ? sin(millis() * 0.001) * 0.2 * intensityFactor : 0));
            
            if (disruption.activated || disruption.intensity > 0) {
                fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                     disruption.opacity * (0.6 + intensityFactor * 0.4));
                stroke(0, 0, 0, 80 * intensityFactor);
                strokeWeight(1 * intensityFactor);
            } else {
                fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], disruption.opacity);
                noStroke();
            }
            
            let size = disruption.size * (1 + (intensityFactor * 0.2));
            triangle(0, -size/2, -size/2, size/2, size/2, size/2);
            
            if (intensityFactor > 0.4) {
                stroke(0, 0, 0, 100 * intensityFactor);
                strokeWeight(1);
                line(-size/3, size/4, size/3, size/4);
                
                if (intensityFactor > 0.7) {
                    stroke(0, 0, 0, 150 * intensityFactor);
                    strokeWeight(1.5);
                    line(0, -size/3, 0, size/6);
                    point(0, size/3);
                }
            }
            
            pop();
            
            if (disruption.interactive && !disruption.activated) {
                noFill();
                stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 40);
                strokeWeight(0.8);
                ellipse(disruption.x, disruption.y, 
                       disruption.size * 1.5 + sin(millis() * 0.002) * 4,
                       disruption.size * 1.5 + sin(millis() * 0.002) * 4);
            }
        }
        
        function drawBlockElement(disruption) {
            let intensityFactor = 0;
            if (disruption.activated || disruption.intensity > 0) {
                intensityFactor = disruption.intensity / disruption.maxIntensity;
            }
            
            push();
            translate(disruption.x, disruption.y);
            rotate(disruption.rotation + (intensityFactor > 0 ? sin(millis() * 0.0015) * 0.2 * intensityFactor : 0));
            
            if (disruption.activated || disruption.intensity > 0) {
                fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                     disruption.opacity * (0.6 + intensityFactor * 0.4));
                stroke(0, 0, 0, 100 * intensityFactor);
                strokeWeight(1 * intensityFactor);
            } else {
                fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], disruption.opacity);
                noStroke();
            }
            
            let width = disruption.width * (1 + (intensityFactor * 0.15));
            let height = disruption.height * (1 + (intensityFactor * 0.15));
            rect(-width/2, -height/2, width, height);
            
            if (intensityFactor > 0.4) {
                stroke(0, 0, 0, 120 * intensityFactor);
                strokeWeight(1);
                line(-width/3, -height/3, width/3, height/3);
                line(-width/3, height/3, width/3, -height/3);
            }
            
            pop();
            
            if (disruption.interactive && !disruption.activated) {
                noFill();
                stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 40);
                strokeWeight(0.8);
                rect(disruption.x - disruption.width*0.75, disruption.y - disruption.height*0.75,
                     disruption.width*1.5 + sin(millis() * 0.002) * 4,
                     disruption.height*1.5 + sin(millis() * 0.002) * 4);
            }
        }
        
        function drawAlertElement(disruption) {
            disruption.phase += disruption.pulseRate * (disruption.activated ? 2 : 0.5);
            
            let intensityFactor = 0;
            if (disruption.activated || disruption.intensity > 0) {
                intensityFactor = disruption.intensity / disruption.maxIntensity;
            }
            
            push();
            translate(disruption.x, disruption.y);
            
            if (disruption.activated || disruption.intensity > 0) {
                noFill();
                stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                      disruption.opacity * (0.7 + intensityFactor * 0.3));
                strokeWeight(2 + intensityFactor);
                
                let radius = disruption.size/2 * (1 + sin(disruption.phase) * 0.1 * intensityFactor);
                arc(0, 0, radius*2, radius*2, PI/8, TWO_PI - PI/8);
                
                stroke(0, 0, 0, disruption.opacity * (0.7 + intensityFactor * 0.3));
                strokeWeight(2 + intensityFactor);
                line(0, -radius*0.4, 0, radius*0.1);
                point(0, radius*0.3);
            } else {
                noFill();
                stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], disruption.opacity * 0.8);
                strokeWeight(1.5);
                ellipse(0, 0, disruption.size, disruption.size);
                
                stroke(0, 0, 0, disruption.opacity * 0.6);
                strokeWeight(1.5);
                let radius = disruption.size/2;
                line(0, -radius*0.3, 0, radius*0.1);
                point(0, radius*0.3);
            }
            
            if (intensityFactor > 0.6) {
                noFill();
                for (let i = 0; i < 3; i++) {
                    let pulseFactor = (sin(disruption.phase * 0.5 - i * 0.7) * 0.5 + 0.5) * intensityFactor;
                    if (pulseFactor > 0.1) {
                        stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                              disruption.opacity * 0.3 * pulseFactor);
                        strokeWeight(1);
                        let pulseRadius = disruption.size * (1.2 + i * 0.3) * pulseFactor;
                        ellipse(0, 0, pulseRadius, pulseRadius);
                    }
                }
            }
            
            pop();
            
            if (disruption.interactive && !disruption.activated) {
                noFill();
                stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 40);
                strokeWeight(0.8);
                ellipse(disruption.x, disruption.y, 
                       disruption.size * 1.5 + sin(millis() * 0.002) * 4,
                       disruption.size * 1.5 + sin(millis() * 0.002) * 4);
            }
        }

        function drawHighlightElements() {
            for (let i = 0; i < highlightElements.length; i++) {
                let highlight = highlightElements[i];
                
                if (timePosition > highlight.startTime) {
                    highlight.visible = true;
                    
                    if (highlight.type === 'path' && highlight.progress < 1) {
                        highlight.progress = min(1, highlight.progress + 0.005);
                    }
                }
                
                if (!highlight.visible) continue;
                
                if (highlight.type === 'platform') {
                    drawPlatformElement(highlight);
                } else if (highlight.type === 'organic') {
                    drawOrganicElement(highlight);
                } else if (highlight.type === 'path') {
                    drawPathElement(highlight);
                }
            }
        }
        
        function drawPlatformElement(highlight) {
            let undulationAmount = sin(millis() * highlight.pulseRate) * 0.08;
            let energyFactor = 0;
            
            if (highlight.activated || highlight.energy > 0) {
                energyFactor = highlight.energy / highlight.maxEnergy;
                
                noFill();
                stroke(colors.brown[0], colors.brown[1], colors.brown[2], 80 * energyFactor);
                strokeWeight(1.5);
                
                let glowWidth = highlight.width * (1 + energyFactor * 0.1);
                let glowHeight = highlight.height * (1 + energyFactor * 0.1);
                rect(highlight.x - glowWidth/2, highlight.y - glowHeight/2, glowWidth, glowHeight);
                fill(colors.brown[0], colors.brown[1], colors.brown[2], 
                    highlight.opacity * (0.7 + energyFactor * 0.3));
            } else {
                fill(colors.brown[0], colors.brown[1], colors.brown[2], highlight.opacity);
                noStroke();
            }
            
            let width = highlight.width * (1 + undulationAmount);
            let height = highlight.height;
            rect(highlight.x - width/2, highlight.y - height/2, width, height);
            
            if (energyFactor > 0.3) {
                stroke(colors.brown[0] * 0.8, colors.brown[1] * 0.8, colors.brown[2] * 0.8, 
                      highlight.opacity * 0.4 * energyFactor);
                strokeWeight(0.8);
                
                for (let i = 0; i < 4; i++) {
                    let y = highlight.y - height/2 + height * (i + 0.5) / 4;
                    let waveAmp = height/10 * energyFactor;
                    
                    beginShape();
                    for (let x = highlight.x - width/2; x <= highlight.x + width/2; x += width/20) {
                        let xOffset = (x - (highlight.x - width/2)) / width;
                        let yOffset = sin(xOffset * 10 + i) * waveAmp;
                        vertex(x, y + yOffset);
                    }
                    endShape();
                }
            }
            
            if (highlight.interactive && !highlight.activated) {
                noFill();
                stroke(colors.brown[0], colors.brown[1], colors.brown[2], 40);
                strokeWeight(0.8);
                rect(highlight.x - highlight.width*0.6, highlight.y - highlight.height,
                     highlight.width*1.2, highlight.height*2 + sin(millis() * 0.0015) * 4);
            }
        }
        
        function drawOrganicElement(highlight) {
            let undulationAmount = sin(millis() * highlight.pulseRate) * 0.08;
            let energyFactor = 0;
            
            if (highlight.activated || highlight.energy > 0) {
                energyFactor = highlight.energy / highlight.maxEnergy;
                
                noFill();
                stroke(colors.brown[0], colors.brown[1], colors.brown[2], 80 * energyFactor);
                strokeWeight(1.5);
                
                push();
                translate(highlight.x, highlight.y);
                rotate(highlight.rotation);
                
                let glowSize = highlight.size * (1 + energyFactor * 0.15);
                
                beginShape();
                for (let i = 0; i < highlight.points; i++) {
                    let angle = TWO_PI * i / highlight.points;
                    let radius = glowSize/2 * (1 + noise(angle * highlight.noiseScale, millis() * 0.0001) * 0.3);
                    let x = cos(angle) * radius;
                    let y = sin(angle) * radius;
                    curveVertex(x, y);
                }
                for (let i = 0; i < 3; i++) {
                    let angle = TWO_PI * i / highlight.points;
                    let radius = glowSize/2 * (1 + noise(angle * highlight.noiseScale, millis() * 0.0001) * 0.3);
                    let x = cos(angle) * radius;
                    let y = sin(angle) * radius;
                    curveVertex(x, y);
                }
                endShape();
                pop();
                
                fill(colors.brown[0], colors.brown[1], colors.brown[2], 
                    highlight.opacity * (0.7 + energyFactor * 0.3));
            } else {
                fill(colors.brown[0], colors.brown[1], colors.brown[2], highlight.opacity);
                noStroke();
            }
            
            let size = highlight.size * (1 + undulationAmount);
            
            push();
            translate(highlight.x, highlight.y);
            rotate(highlight.rotation + (energyFactor > 0 ? sin(millis() * 0.001) * 0.1 : 0));
            
            beginShape();
            for (let i = 0; i < highlight.points; i++) {
                let angle = TWO_PI * i / highlight.points;
                let radius = size/2 * (1 + noise(angle * highlight.noiseScale, millis() * 0.0002 * (1 + energyFactor)) * 0.3);
                let x = cos(angle) * radius;
                let y = sin(angle) * radius;
                curveVertex(x, y);
            }
            for (let i = 0; i < 3; i++) {
                let angle = TWO_PI * i / highlight.points;
                let radius = size/2 * (1 + noise(angle * highlight.noiseScale, millis() * 0.0002 * (1 + energyFactor)) * 0.3);
                let x = cos(angle) * radius;
                let y = sin(angle) * radius;
                curveVertex(x, y);
            }
            endShape();
            
            if (energyFactor > 0.4) {
                noFill();
                stroke(colors.brown[0] * 0.8, colors.brown[1] * 0.8, colors.brown[2] * 0.8, 
                      highlight.opacity * 0.5 * energyFactor);
                strokeWeight(1);
                
                beginShape();
                for (let i = 0; i < highlight.points; i++) {
                    let angle = TWO_PI * i / highlight.points;
                    let radius = size/3 * (1 + noise(angle * highlight.noiseScale * 2, millis() * 0.0002) * 0.2);
                    let x = cos(angle) * radius;
                    let y = sin(angle) * radius;
                    curveVertex(x, y);
                }
                for (let i = 0; i < 3; i++) {
                    let angle = TWO_PI * i / highlight.points;
                    let radius = size/3 * (1 + noise(angle * highlight.noiseScale * 2, millis() * 0.0002) * 0.2);
                    let x = cos(angle) * radius;
                    let y = sin(angle) * radius;
                    curveVertex(x, y);
                }
                endShape();
            }
            pop();
            
            if (highlight.interactive && !highlight.activated) {
                noFill();
                stroke(colors.brown[0], colors.brown[1], colors.brown[2], 40);
                strokeWeight(0.8);
                ellipse(highlight.x, highlight.y, 
                       highlight.size * 1.3 + sin(millis() * 0.0015) * 4,
                       highlight.size * 1.3 + sin(millis() * 0.0015) * 4);
            }
        }
        
        function drawPathElement(highlight) {
            let energyFactor = 0;
            
            if (highlight.activated || highlight.energy > 0) {
                energyFactor = highlight.energy / highlight.maxEnergy;
                
                noFill();
                stroke(colors.brown[0], colors.brown[1], colors.brown[2], 70 * energyFactor);
                strokeWeight(highlight.width + 1.5);
                
                if (highlight.points.length === 4) {
                    let p = highlight.points;
                    let progressLength = highlight.progress;
                    
                    bezier(
                        p[0].x, p[0].y,
                        lerp(p[0].x, p[1].x, progressLength), lerp(p[0].y, p[1].y, progressLength),
                        lerp(p[2].x, p[3].x, progressLength), lerp(p[2].y, p[3].y, progressLength),
                        lerp(p[0].x, p[3].x, progressLength), lerp(p[0].y, p[3].y, progressLength)
                    );
                }
                stroke(colors.brown[0], colors.brown[1], colors.brown[2], 
                      highlight.opacity * (0.7 + energyFactor * 0.3));
            } else {
                stroke(colors.brown[0], colors.brown[1], colors.brown[2], highlight.opacity);
            }
            
            strokeWeight(highlight.width);
            noFill();
            
            if (highlight.points.length === 4) {
                let p = highlight.points;
                let progressLength = highlight.progress;
                drawDashedBezier(p[0].x, p[0].y, p[1].x, p[1].y, p[2].x, p[2].y, p[3].x, p[3].y,
                    highlight.dashArray, progressLength);
            }
            
            if (energyFactor > 0.5) {
                noStroke();
                fill(colors.brown[0], colors.brown[1], colors.brown[2], 160 * energyFactor);
                
                if (highlight.points.length === 4) {
                    let p = highlight.points;
                    let numParticles = floor(4 * highlight.progress);
                    
                    for (let j = 0; j < numParticles; j++) {
                        let t = (j / numParticles + (millis() % 3000) / 3000) % 1;
                        if (t > highlight.progress) continue;
                        
                        let x = bezierPoint(p[0].x, p[1].x, p[2].x, p[3].x, t);
                        let y = bezierPoint(p[0].y, p[1].y, p[2].y, p[3].y, t);
                        let particleSize = 2.5 + energyFactor * 2;
                        ellipse(x, y, particleSize, particleSize);
                    }
                }
            }
            
            if (highlight.interactive && !highlight.activated) {
                noFill();
                stroke(colors.brown[0], colors.brown[1], colors.brown[2], 40);
                strokeWeight(0.8);
                
                if (highlight.points.length === 4) {
                    let p = highlight.points;
                    ellipse(p[0].x, p[0].y, 10 + sin(millis() * 0.0015) * 3, 10 + sin(millis() * 0.0015) * 3);
                    ellipse(p[3].x, p[3].y, 10 + sin(millis() * 0.0015 + 1) * 3, 10 + sin(millis() * 0.0015 + 1) * 3);
                }
            }
        }
        
        // OPTIMIZED: Reduced segments from 100 to 50
        function drawDashedBezier(x1, y1, x2, y2, x3, y3, x4, y4, pattern, progressLimit) {
            let dashLength = pattern[0];
            let gapLength = pattern[1];
            let numSegments = 50; // REDUCED from 100
            
            let x = x1;
            let y = y1;
            let prevX = x;
            let prevY = y;
            let dashOn = true;
            let dashDistance = 0;
            
            for (let i = 1; i <= numSegments; i++) {
                let t = i / numSegments;
                if (t > progressLimit) break;
                
                x = bezierPoint(x1, x2, x3, x4, t);
                y = bezierPoint(y1, y2, y3, y4, t);
                
                let segmentLength = dist(prevX, prevY, x, y);
                dashDistance += segmentLength;
                
                if (dashOn && dashDistance >= dashLength) {
                    dashOn = false;
                    dashDistance = 0;
                } else if (!dashOn && dashDistance >= gapLength) {
                    dashOn = true;
                    dashDistance = 0;
                }
                
                if (dashOn) {
                    line(prevX, prevY, x, y);
                }
                
                prevX = x;
                prevY = y;
            }
        }

        // OPTIMIZED: Batch drawing for connection lines
        function drawConnectionLines() {
            for (let i = 0; i < connectionLines.length; i++) {
                let line = connectionLines[i];
                
                if (timePosition <= line.startTime) continue;
                
                if (isAnimating && line.progress < 1) {
                    line.progress = min(1, line.progress + 0.004);
                }
                
                let startX, startY, endX, endY;
                
                if (line.startElement === 'framework') {
                    let framework = frameworkElements[line.startIndex];
                    if (framework.type === 'line') {
                        startX = framework.x + cos(framework.angle) * framework.length/2;
                        startY = framework.y + sin(framework.angle) * framework.length/2;
                    } else {
                        startX = framework.x;
                        startY = framework.y;
                    }
                } else if (line.startElement === 'disruption') {
                    startX = disruptionElements[line.startIndex].x;
                    startY = disruptionElements[line.startIndex].y;
                } else {
                    let highlight = highlightElements[line.startIndex];
                    if (highlight.type === 'path') {
                        startX = highlight.points[0].x;
                        startY = highlight.points[0].y;
                    } else {
                        startX = highlight.x;
                        startY = highlight.y;
                    }
                }
                
                if (line.endElement === 'framework') {
                    let framework = frameworkElements[line.endIndex];
                    if (framework.type === 'line') {
                        endX = framework.x + cos(framework.angle) * framework.length/2;
                        endY = framework.y + sin(framework.angle) * framework.length/2;
                    } else {
                        endX = framework.x;
                        endY = framework.y;
                    }
                } else if (line.endElement === 'disruption') {
                    endX = disruptionElements[line.endIndex].x;
                    endY = disruptionElements[line.endIndex].y;
                } else {
                    let highlight = highlightElements[line.endIndex];
                    if (highlight.type === 'path') {
                        endX = highlight.points[3].x;
                        endY = highlight.points[3].y;
                    } else {
                        endX = highlight.x;
                        endY = highlight.y;
                    }
                }
                
                let startVisible = false;
                let endVisible = false;
                
                if (line.startElement === 'framework') {
                    startVisible = frameworkElements[line.startIndex].visible;
                } else if (line.startElement === 'disruption') {
                    startVisible = disruptionElements[line.startIndex].visible;
                } else {
                    startVisible = highlightElements[line.startIndex].visible;
                }
                
                if (line.endElement === 'framework') {
                    endVisible = frameworkElements[line.endIndex].visible;
                } else if (line.endElement === 'disruption') {
                    endVisible = disruptionElements[line.endIndex].visible;
                } else {
                    endVisible = highlightElements[line.endIndex].visible;
                }
                
                if (!startVisible || !endVisible) continue;
                
                let lineColor;
                if (line.endElement === 'framework') {
                    lineColor = colors.black;
                } else if (line.endElement === 'disruption') {
                    lineColor = colors.yellow;
                } else {
                    lineColor = colors.brown;
                }
                
                let isActivated = false;
                let activationLevel = 0;
                
                if (line.startElement === 'framework') {
                    let framework = frameworkElements[line.startIndex];
                    isActivated = framework.activated;
                    activationLevel = framework.tension / framework.maxTension;
                } else if (line.startElement === 'disruption') {
                    let disruption = disruptionElements[line.startIndex];
                    isActivated = disruption.activated;
                    activationLevel = disruption.intensity / disruption.maxIntensity;
                } else {
                    let highlight = highlightElements[line.startIndex];
                    isActivated = highlight.activated;
                    activationLevel = highlight.energy / highlight.maxEnergy;
                }
                
                let endActivated = false;
                let endActivationLevel = 0;
                
                if (line.endElement === 'framework') {
                    let framework = frameworkElements[line.endIndex];
                    endActivated = framework.activated;
                    endActivationLevel = framework.tension / framework.maxTension;
                } else if (line.endElement === 'disruption') {
                    let disruption = disruptionElements[line.endIndex];
                    endActivated = disruption.activated;
                    endActivationLevel = disruption.intensity / disruption.maxIntensity;
                } else {
                    let highlight = highlightElements[line.endIndex];
                    endActivated = highlight.activated;
                    endActivationLevel = highlight.energy / highlight.maxEnergy;
                }
                
                isActivated = isActivated || endActivated;
                activationLevel = max(activationLevel, endActivationLevel);
                
                let breakPoint = 0.6;
                if (line.broken && !isActivated) {
                    breakPoint = random(0.4, 0.7);
                }
                
                let distance = dist(startX, startY, endX, endY);
                let numDots = floor(distance / line.dotSpacing);
                let dotsToShow = line.broken && !isActivated ? 
                                floor(numDots * breakPoint) : numDots;
                
                noStroke();
                
                // OPTIMIZED: Skip every other dot for inactive lines
                let skipDots = !isActivated ? 2 : 1;
                
                for (let i = 0; i <= min(dotsToShow, numDots * line.progress); i += skipDots) {
                    let t = i / numDots;
                    let x, y;
                    
                    if (isActivated && activationLevel > 0.4) {
                        let midX = (startX + endX) / 2;
                        let midY = (startY + endY) / 2 - 5 * sin(PI * t);
                        let u = 1 - t;
                        x = u*u*startX + 2*u*t*midX + t*t*endX;
                        y = u*u*startY + 2*u*t*midY + t*t*endY;
                        
                        let oscAmount = activationLevel * 2 * sin(t * PI * 3 + millis() * 0.002);
                        let perpX = -(endY - startY);
                        let perpY = (endX - startX);
                        let perpLen = sqrt(perpX*perpX + perpY*perpY);
                        
                        if (perpLen > 0) {
                            x += (perpX / perpLen) * oscAmount;
                            y += (perpY / perpLen) * oscAmount;
                        }
                    } else {
                        x = lerp(startX, endX, t);
                        y = lerp(startY, endY, t);
                    }
                    
                    if (isActivated) {
                        fill(lineColor[0], lineColor[1], lineColor[2], 
                            line.opacity * (0.6 + activationLevel * 0.4));
                        let pulseSize = line.dotSize * (1 + sin(millis() * 0.002 + i * 0.2) * 0.2);
                        ellipse(x, y, pulseSize + activationLevel * 1.5);
                        
                        if (line.broken && i > dotsToShow && i % 2 === 0) {
                            fill(lineColor[0], lineColor[1], lineColor[2], 
                                line.opacity * 0.4 * activationLevel);
                            ellipse(x, y, pulseSize * 0.7);
                        }
                    } else {
                        fill(lineColor[0], lineColor[1], lineColor[2], line.opacity);
                        ellipse(x, y, line.dotSize);
                    }
                }
                
                if (line.broken && !isActivated) {
                    let t = breakPoint;
                    let x = lerp(startX, endX, t);
                    let y = lerp(startY, endY, t);
                    
                    stroke(lineColor[0], lineColor[1], lineColor[2], line.opacity * 0.7);
                    strokeWeight(1);
                    let markSize = line.dotSize * 1.5;
                    line(x - markSize/2, y - markSize/2, x + markSize/2, y + markSize/2);
                    line(x - markSize/2, y + markSize/2, x + markSize/2, y - markSize/2);
                }
            }
        }
        
        function drawDisappointmentCenters() {
            for (let i = 0; i < disappointmentCenters.length; i++) {
                let center = disappointmentCenters[i];
                
                if (timePosition <= center.startTime) continue;
                
                if (center.opacity < center.targetOpacity) {
                    center.opacity = min(center.targetOpacity, center.opacity + 0.8);
                }
                
                let pulseAmount = sin(millis() * center.pulseRate) * 0.1;
                let pulseSize = center.size * (1 + pulseAmount);
                
                if (i === activeDisappointmentCenter && center.activationProgress > 0) {
                    for (let j = 0; j < 2; j++) {
                        let expandedSize = pulseSize + j * 15 * center.activationProgress;
                        let glowOpacity = (70 - j * 25) * center.activationProgress;
                        
                        noFill();
                        let blendedR = lerp(colors.black[0], colors.brown[0], 0.3);
                        let blendedG = lerp(colors.black[1], colors.brown[1], 0.3);
                        let blendedB = lerp(colors.black[2], colors.brown[2], 0.3);
                        
                        stroke(blendedR, blendedG, blendedB, glowOpacity);
                        strokeWeight(1.2 - j * 0.3);
                        
                        let segments = 6;
                        for (let k = 0; k < segments; k++) {
                            let startAngle = TWO_PI * k / segments;
                            let endAngle = TWO_PI * (k + 0.8) / segments;
                            arc(center.x, center.y, expandedSize, expandedSize, startAngle, endAngle);
                        }
                    }
                }
                
                noFill();
                stroke(0, 0, 0, center.opacity);
                strokeWeight(1.8);
                
                let segments = 5;
                for (let j = 0; j < segments; j++) {
                    let startAngle = TWO_PI * j / segments + millis() * 0.0002;
                    let endAngle = TWO_PI * (j + 0.8) / segments + millis() * 0.0002;
                    arc(center.x, center.y, pulseSize, pulseSize, startAngle, endAngle);
                }
                
                fill(0, 0, 0, center.opacity * 0.1);
                noStroke();
                arc(center.x, center.y, pulseSize * 0.4, pulseSize * 0.4, PI/4, TWO_PI - PI/4);
                
                if (!center.activated) {
                    fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                        60 + 20 * sin(millis() * 0.003));
                    noStroke();
                    
                    push();
                    translate(center.x, center.y);
                    let symbolSize = 10;
                    rect(-symbolSize, -symbolSize/4, symbolSize*0.7, symbolSize/2);
                    rect(symbolSize*0.3, -symbolSize/4, symbolSize*0.7, symbolSize/2);
                    pop();
                }
            }
        }
        
        function showDisappointmentResonance(message, x, y) {
            const resonance = document.getElementById('disappointment-resonance');
            resonance.innerHTML = message;
            
            let posX = x;
            let posY = y - 60;
            
            if (posX < 20) posX = 20;
            if (posX > window.innerWidth - 270) posX = window.innerWidth - 270;
            if (posY < 20) posY = 20;
            if (posY > window.innerHeight - 100) posY = window.innerHeight - 100;
            
            resonance.style.left = posX + 'px';
            resonance.style.top = posY + 'px';
            resonance.style.transform = 'translateY(0)';
            resonance.style.opacity = '1';
            
            setTimeout(() => {
                resonance.style.opacity = '0';
                resonance.style.transform = 'translateY(20px)';
            }, 5000);
        }

        function windowResized() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                resizeCanvas(windowWidth, windowHeight);
                repositionElements();
                updateLayoutForOrientation();
            }, 200); // Increased debounce
        }
        
        function repositionElements() {
            const widthFactor = windowWidth / width;
            const heightFactor = windowHeight / height;
            
            width = windowWidth;
            height = windowHeight;
            
            for (let i = 0; i < handOutlinePoints.length; i++) {
                handOutlinePoints[i].x *= widthFactor;
                handOutlinePoints[i].y *= heightFactor;
            }
            
            for (let framework of frameworkElements) {
                framework.x *= widthFactor;
                framework.y *= heightFactor;
                
                if (framework.type === 'line') {
                    framework.length *= widthFactor;
                } else if (framework.type === 'dots') {
                    framework.size *= widthFactor;
                } else if (framework.type === 'container') {
                    framework.width *= widthFactor;
                    framework.height *= heightFactor;
                }
            }
            
            for (let disruption of disruptionElements) {
                disruption.x *= widthFactor;
                disruption.y *= heightFactor;
                
                if (disruption.type === 'triangle' || disruption.type === 'alert') {
                    disruption.size *= widthFactor;
                } else if (disruption.type === 'block') {
                    disruption.width *= widthFactor;
                    disruption.height *= heightFactor;
                }
            }
            
            for (let highlight of highlightElements) {
                if (highlight.type !== 'path') {
                    highlight.x *= widthFactor;
                    highlight.y *= heightFactor;
                    
                    if (highlight.type === 'platform') {
                        highlight.width *= widthFactor;
                        highlight.height *= heightFactor;
                    } else if (highlight.type === 'organic') {
                        highlight.size *= widthFactor;
                    }
                } else {
                    for (let point of highlight.points) {
                        point.x *= widthFactor;
                        point.y *= heightFactor;
                    }
                }
            }
            
            for (let center of disappointmentCenters) {
                center.x *= widthFactor;
                center.y *= heightFactor;
                center.size *= widthFactor;
            }
        }
        
        function mousePressed() {
            const currentTime = millis();
            if (currentTime - lastInteractionTime < 300) {
                return false;
            }
            lastInteractionTime = currentTime;
            
            if (document.getElementById('landing-overlay').style.display !== 'none') {
                return false;
            }
            
            for (let i = 0; i < disappointmentCenters.length; i++) {
                let center = disappointmentCenters[i];
                
                if (timePosition > center.startTime) {
                    let d = dist(mouseX, mouseY, center.x, center.y);
                    
                    if (d < center.size / 2) {
                        center.activated = !center.activated;
                        
                        if (center.activated) {
                            activeDisappointmentCenter = i;
                            centerActivated = true;
                            showDisappointmentResonance(center.resonance, center.x, center.y);
                            
                            for (let element of center.elements) {
                                if (element.type === 'framework') {
                                    frameworkElements[element.index].activated = true;
                                    frameworkElements[element.index].activatedTime = millis();
                                    frameworkElements[element.index].tension = frameworkElements[element.index].maxTension * 0.7;
                                } else if (element.type === 'disruption') {
                                    disruptionElements[element.index].activated = true;
                                    disruptionElements[element.index].activatedTime = millis();
                                    disruptionElements[element.index].intensity = disruptionElements[element.index].maxIntensity * 0.8;
                                } else {
                                    highlightElements[element.index].activated = true;
                                    highlightElements[element.index].activatedTime = millis();
                                    highlightElements[element.index].energy = highlightElements[element.index].maxEnergy * 0.75;
                                }
                            }
                        } else {
                            activeDisappointmentCenter = null;
                            centerActivated = false;
                        }
                        
                        return false;
                    }
                }
            }
            
            let clickedElement = false;
            
            for (let i = 0; i < frameworkElements.length; i++) {
                let framework = frameworkElements[i];
                
                if (framework.visible && framework.interactive) {
                    let hitTest = false;
                    
                    if (framework.type === 'line') {
                        let lineStart = createVector(framework.x, framework.y);
                        let lineEnd = createVector(
                            framework.x + cos(framework.angle) * framework.length,
                            framework.y + sin(framework.angle) * framework.length
                        );
                        
                        let mousePt = createVector(mouseX, mouseY);
                        let projection = projectionPointOnLine(mousePt, lineStart, lineEnd);
                        let d = dist(mouseX, mouseY, projection.x, projection.y);
                        let dStart = dist(projection.x, projection.y, lineStart.x, lineStart.y);
                        let dEnd = dist(projection.x, projection.y, lineEnd.x, lineEnd.y);
                        let lineLength = dist(lineStart.x, lineStart.y, lineEnd.x, lineEnd.y);
                        hitTest = (d < framework.width + 8) && (dStart + dEnd <= lineLength + 0.1);
                    } else if (framework.type === 'dots') {
                        let d = dist(mouseX, mouseY, framework.x, framework.y);
                        hitTest = (d < framework.size / 2);
                    } else if (framework.type === 'container') {
                        if (framework.shape === 'rect') {
                            hitTest = (mouseX > framework.x - framework.width/2 &&
                                      mouseX < framework.x + framework.width/2 &&
                                      mouseY > framework.y - framework.height/2 &&
                                      mouseY < framework.y + framework.height/2);
                        } else {
                            let d = dist(mouseX, mouseY, framework.x, framework.y);
                            hitTest = (d < framework.width/2);
                        }
                    }
                    
                    if (hitTest) {
                        framework.activated = !framework.activated;
                        framework.activatedTime = millis();
                        
                        if (framework.activated) {
                            framework.tension = framework.maxTension * 0.7;
                            showDisappointmentResonance(getRandomResonance(), 
                                framework.type === 'line' ? 
                                framework.x + cos(framework.angle) * framework.length/2 : 
                                framework.x, 
                                framework.type === 'line' ? 
                                framework.y + sin(framework.angle) * framework.length/2 : 
                                framework.y);
                        }
                        
                        clickedElement = true;
                        break;
                    }
                }
            }
            
            if (clickedElement) return false;
            
            for (let i = 0; i < disruptionElements.length; i++) {
                let disruption = disruptionElements[i];
                
                if (disruption.visible && disruption.interactive) {
                    let hitTest = false;
                    
                    if (disruption.type === 'triangle') {
                        let d = dist(mouseX, mouseY, disruption.x, disruption.y);
                        hitTest = (d < disruption.size * 0.7);
                    } else if (disruption.type === 'block') {
                        let rotatedX = cos(-disruption.rotation) * (mouseX - disruption.x) - 
                                      sin(-disruption.rotation) * (mouseY - disruption.y) + disruption.x;
                        let rotatedY = sin(-disruption.rotation) * (mouseX - disruption.x) + 
                                      cos(-disruption.rotation) * (mouseY - disruption.y) + disruption.y;
                        hitTest = (rotatedX > disruption.x - disruption.width/2 &&
                                  rotatedX < disruption.x + disruption.width/2 &&
                                  rotatedY > disruption.y - disruption.height/2 &&
                                  rotatedY < disruption.y + disruption.height/2);
                    } else if (disruption.type === 'alert') {
                        let d = dist(mouseX, mouseY, disruption.x, disruption.y);
                        hitTest = (d < disruption.size/2);
                    }
                    
                    if (hitTest) {
                        disruption.activated = !disruption.activated;
                        disruption.activatedTime = millis();
                        
                        if (disruption.activated) {
                            disruption.intensity = disruption.maxIntensity * 0.8;
                            showDisappointmentResonance(getRandomResonance(), disruption.x, disruption.y);
                        }
                        
                        clickedElement = true;
                        break;
                    }
                }
            }
            
            if (clickedElement) return false;
            
            for (let i = 0; i < highlightElements.length; i++) {
                let highlight = highlightElements[i];
                
                if (highlight.visible && highlight.interactive) {
                    let hitTest = false;
                    
                    if (highlight.type === 'platform') {
                        hitTest = (mouseX > highlight.x - highlight.width/2 &&
                                  mouseX < highlight.x + highlight.width/2 &&
                                  mouseY > highlight.y - highlight.height/2 &&
                                  mouseY < highlight.y + highlight.height/2);
                    } else if (highlight.type === 'organic') {
                        let d = dist(mouseX, mouseY, highlight.x, highlight.y);
                        hitTest = (d < highlight.size/2);
                    } else if (highlight.type === 'path') {
                        if (highlight.points.length === 4) {
                            let p = highlight.points;
                            let hitTestPoints = 10;
                            
                            for (let j = 0; j < hitTestPoints; j++) {
                                let t = j / (hitTestPoints - 1);
                                let x = bezierPoint(p[0].x, p[1].x, p[2].x, p[3].x, t);
                                let y = bezierPoint(p[0].y, p[1].y, p[2].y, p[3].y, t);
                                let d = dist(mouseX, mouseY, x, y);
                                
                                if (d < highlight.width + 10) {
                                    hitTest = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (hitTest) {
                        highlight.activated = !highlight.activated;
                        highlight.activatedTime = millis();
                        
                        if (highlight.activated) {
                            highlight.energy = highlight.maxEnergy * 0.75;
                            
                            if (highlight.type === 'path') {
                                let p = highlight.points;
                                showDisappointmentResonance(getRandomResonance(), 
                                    (p[0].x + p[3].x)/2, 
                                    (p[0].y + p[3].y)/2);
                            } else {
                                showDisappointmentResonance(getRandomResonance(), highlight.x, highlight.y);
                            }
                        }
                        
                        clickedElement = true;
                        break;
                    }
                }
            }
            
            if (clickedElement) return false;
            
            isAnimating = !isAnimating;
            
            if (!isAnimating && soundEnabled && soundLoaded && disappointmentSound && disappointmentSound.isPlaying()) {
                disappointmentSound.setVolume(0.3, 1.5);
            } else if (isAnimating && soundEnabled && soundLoaded && disappointmentSound) {
                if (!disappointmentSound.isPlaying()) {
                    disappointmentSound.loop();
                }
                disappointmentSound.setVolume(0.6, 1.5);
            }
            
            return false;
        }
        
        function projectionPointOnLine(p, a, b) {
            let ap = p5.Vector.sub(p, a);
            let ab = p5.Vector.sub(b, a);
            ab.normalize();
            ab.mult(ap.dot(ab));
            return p5.Vector.add(a, ab);
        }
        
        function touchStarted() {
            if (getAudioContext().state !== 'running') {
                getAudioContext().resume();
            }
            return mousePressed();
        }

        function touchMoved() {
            if (mouseY < height && mouseX < width) {
                return false;
            }
        }
    </script>
</body>
</html>
