<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Nostalgia - Emotional Experience</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f5f5f7;
            font-family: 'Roboto Mono', monospace;
            -webkit-text-size-adjust: 100%;
            touch-action: none;
        }
        
        /* Landing screen that appears first */
        #landing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(245, 245, 247, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            box-sizing: border-box;
            padding: 20px;
            transition: opacity 1s ease-in-out;
        }
        
        .landing-title {
            font-size: 24px;
            font-weight: 500;
            margin-bottom: 40px;
            text-align: center;
            letter-spacing: 1px;
        }
        
        .emotion-name {
            font-size: 36px;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #50377E; /* Purple for nostalgia */
        }
        
        .emotion-description {
            font-size: 14px;
            line-height: 1.4;
            max-width: 600px;
            text-align: center;
            margin-bottom: 80px;
            opacity: 0.8;
        }
        
        .start-button {
            padding: 15px 35px;
            background-color: #333;
            color: #fff;
            border: none;
            border-radius: 30px;
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .start-button:active {
            transform: scale(0.98);
        }
        
        /* Canvas for the animation */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        /* Memory echo popup */
        .memory-echo {
            position: fixed;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 15px;
            max-width: 250px;
            font-size: 13px;
            line-height: 1.4;
            color: #333;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            transform: translateY(20px);
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            pointer-events: none;
            z-index: 100;
            text-align: center;
            border-left: 3px solid #50377E;
        }
        
        /* Controls panel */
        .controls {
            position: fixed;
            bottom: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .control-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }
        
        .control-button svg {
            width: 20px;
            height: 20px;
        }
        
        /* Hint message */
        .hint {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background-color: rgba(255, 255, 255, 0.85);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 50;
        }
        
        /* Timeline slider */
        .timeline {
            position: fixed;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            width: 70%;
            max-width: 500px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            z-index: 40;
            opacity: 0;
            transition: opacity 0.5s;
            display: flex;
            align-items: center;
            padding: 0 15px;
        }
        
        .timeline-bar {
            width: 100%;
            height: 4px;
            background-color: rgba(80, 55, 126, 0.2);
            border-radius: 2px;
            position: relative;
        }
        
        .timeline-progress {
            height: 100%;
            background-color: rgba(80, 55, 126, 0.8);
            border-radius: 2px;
            width: 0%;
            transition: width 0.3s;
        }
        
        .timeline-handle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #50377E;
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- Initial landing overlay -->
    <div id="landing-overlay">
        <h1 class="landing-title">Emotional Collage Experience</h1>
        <h2 class="emotion-name" id="emotion-title">NOSTALGIA</h2>
        <p class="emotion-description" id="emotion-description">
            A reflection on the bittersweet remembrance of things past, the emotional texture of memory and temporal distance.
            <br><b>Analysis by Claude</b>
        </p>
        <button class="start-button" id="start-experience">Begin Experience</button>
    </div>
    
    <!-- Memory echo popup that appears when interacting with elements -->
    <div class="memory-echo" id="memory-echo"></div>
    
    <!-- Control buttons -->
    <div class="controls" id="controls">
        <div class="control-button" id="sound-toggle">
            <svg viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2">
                <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                <path id="sound-waves" d="M15.54 8.46a5 5 0 0 1 0 7.07M19.07 4.93a10 10 0 0 1 0 14.14"></path>
            </svg>
        </div>
        <div class="control-button" id="reset-button">
            <svg viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2">
                <path d="M23 4v6h-6"></path>
                <path d="M1 20v-6h6"></path>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
        </div>
    </div>
    
    <!-- Hint for users -->
    <div class="hint" id="hint">Tap on elements to experience nostalgia</div>
    
    <!-- Timeline interface -->
    <div class="timeline" id="timeline">
        <div class="timeline-bar" id="timeline-bar">
            <div class="timeline-progress" id="timeline-progress"></div>
            <div class="timeline-handle" id="timeline-handle"></div>
        </div>
    </div>
    
    <script>
        let isAnimating = true;
        let soundEnabled = true;
        let nostalgiaSound;
        let soundLoaded = false;
        let timelineActive = false;
        let isDraggingTimeline = false;
        let timePosition = 0;
        let previousTimePosition = 0;
        let activatedTimeline = false;
        
        // Memory echoes - text snippets that appear when interacting with elements
        const memoryEchoes = [
            "I remember the feeling of sunlight through autumn leaves",
            "That song from when we used to drive with the windows down",
            "The smell of grandmother's kitchen on Sunday mornings",
            "School hallways, echoing with laughter now distant",
            "Summer evenings, with days that seemed to last forever",
            "Old photographs, faces looking back through time",
            "The taste of childhood treats we can't find anymore",
            "Places that exist now only in our memories",
            "Voices we can still hear, though years have passed",
            "Games we played before screens filled our time",
            "Books that shaped how we see the world",
            "That first moment of connection, now weathered by time",
            "Holiday traditions that slowly evolved as we grew",
            "The comfort of familiar rooms now changed or gone",
            "The sound of rain on the roof of our first home"
        ];
        
        // Color palette for Nostalgia
        const colors = {
            purple: [80, 55, 126],     // Deep purple - Memory fragments (darker)
            lightPurple: [140, 110, 200], // Light purple for highlights
            yellow: [255, 216, 0],      // Yellow - Emotional response
            bronze: [205, 127, 50]      // Bronze - Grounding elements
        };
        
        // Elements for each conceptual layer
        let memoryFragments = [];     // Purple elements - fragments of memory
        let emotionalResponse = [];   // Yellow elements - emotional reaction to memories
        let groundingElements = [];   // Bronze elements - anchoring elements
        
        // Memory pathways that connect elements
        let memoryPathways = [];
        
        // Hand outline coordinates (will gradually appear)
        let handOutlinePoints = [];
        let handProgress = 0;
        
        // Interactive elements
        let focalPoints = []; // Special interactive memory points
        let activeFocalPoint = null;
        let focalPointActivated = false;
        
        // Timeline tracking
        let timelineProgress = 0;
        
        // Setup for landing page interaction
        document.getElementById('start-experience').addEventListener('click', function() {
            // Fade out landing overlay
            document.getElementById('landing-overlay').style.opacity = '0';
            
            // After fading out, remove from DOM
            setTimeout(() => {
                document.getElementById('landing-overlay').style.display = 'none';
                
                // Start animation
                isAnimating = true;
                loop();
                
                // Start sound if enabled
                if (soundEnabled && soundLoaded) {
                    try {
                        nostalgiaSound.loop();
                        nostalgiaSound.setVolume(0);
                        nostalgiaSound.setVolume(0.6, 2); // Fade in over 2 seconds
                    } catch(e) {
                        console.error("Error playing sound:", e);
                    }
                }
                
                // Show controls and hint
                setTimeout(() => {
                    document.getElementById('controls').style.opacity = '1';
                    document.getElementById('hint').style.opacity = '1';
                    
                    // Hide hint after 5 seconds
                    setTimeout(() => {
                        document.getElementById('hint').style.opacity = '0';
                    }, 5000);
                }, 2000);
            }, 1000);
        });
        
        // Sound toggle
        document.getElementById('sound-toggle').addEventListener('click', function() {
            soundEnabled = !soundEnabled;
            
            // Update sound wave visibility
            document.getElementById('sound-waves').style.opacity = soundEnabled ? '1' : '0';
            
            if (soundEnabled && nostalgiaSound && !nostalgiaSound.isPlaying()) {
                nostalgiaSound.loop();
                nostalgiaSound.setVolume(0);
                nostalgiaSound.setVolume(0.6, 1);
            } else if (!soundEnabled && nostalgiaSound && nostalgiaSound.isPlaying()) {
                nostalgiaSound.setVolume(0, 1);
                setTimeout(() => {
                    nostalgiaSound.pause();
                }, 1000);
            }
        });
        
        // Reset button
        document.getElementById('reset-button').addEventListener('click', function() {
            // Reset the experience
            timePosition = 0;
            previousTimePosition = 0;
            
            resetExperience();
            
            // Update timeline
            updateTimelineUI();
        });
        
        // Timeline interaction
        document.getElementById('timeline-bar').addEventListener('mousedown', startTimelineDrag);
        document.getElementById('timeline-bar').addEventListener('touchstart', startTimelineDrag, { passive: true });
        
        function startTimelineDrag(e) {
            isDraggingTimeline = true;
            updateTimelinePosition(e);
            
            // Add document-level event listeners for drag and end
            document.addEventListener('mousemove', updateTimelinePosition);
            document.addEventListener('touchmove', updateTimelinePosition, { passive: true });
            document.addEventListener('mouseup', endTimelineDrag);
            document.addEventListener('touchend', endTimelineDrag);
        }
        
        function updateTimelinePosition(e) {
            if (!isDraggingTimeline) return;
            
            const timeline = document.getElementById('timeline-bar');
            const rect = timeline.getBoundingClientRect();
            
            // Get the x position relative to the timeline
            let clientX;
            if (e.type.startsWith('touch')) {
                clientX = e.touches[0].clientX;
            } else {
                clientX = e.clientX;
            }
            
            // Calculate percentage position
            let percentage = (clientX - rect.left) / rect.width;
            percentage = Math.max(0, Math.min(1, percentage));
            
            // Update UI
            document.getElementById('timeline-progress').style.width = `${percentage * 100}%`;
            document.getElementById('timeline-handle').style.left = `${percentage * 100}%`;
            
            // Update timeline position
            timePosition = percentage * 30000; // 30 seconds of "memory timeline"
            
            // Set time position for elements
            setTimePosition(timePosition);
        }
        
        function endTimelineDrag() {
            isDraggingTimeline = false;
            document.removeEventListener('mousemove', updateTimelinePosition);
            document.removeEventListener('touchmove', updateTimelinePosition);
            document.removeEventListener('mouseup', endTimelineDrag);
            document.removeEventListener('touchend', endTimelineDrag);
            
            previousTimePosition = timePosition;
        }
        
        function updateTimelineUI() {
            // Calculate percentage
            const percentage = timePosition / 30000;
            
            // Update UI
            document.getElementById('timeline-progress').style.width = `${percentage * 100}%`;
            document.getElementById('timeline-handle').style.left = `${percentage * 100}%`;
        }
        
        function preload() {
            // Pre-load sound
            soundLoaded = false;
            nostalgiaSound = loadSound('nostalgia_soundscape.mp3', 
                function() {
                    console.log("Sound loaded successfully");
                    soundLoaded = true;
                },
                function(err) {
                    console.error("Error loading sound:", err);
                    soundEnabled = false;
                }
            );
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            
            // Define hand outline points - a simplified hand silhouette
            createHandOutline();
            
            // Create memory fragments (purple elements)
            for (let i = 0; i < 28; i++) {
                memoryFragments.push({
                    x: random(width * 0.1, width * 0.9),
                    y: random(height * 0.1, height * 0.9),
                    size: random(5, 15),
                    opacity: random(150, 230),
                    startTime: i * 500,
                    visible: false,
                    interactive: random() > 0.6,
                    activated: false,
                    activatedTime: 0,
                    pulseRate: random(0.001, 0.003)
                });
            }
            
            // Create memory pathways connecting memory fragments
            for (let i = 0; i < memoryFragments.length - 1; i++) {
                memoryPathways.push({
                    start: i,
                    end: (i + 1) % memoryFragments.length,
                    progress: 0,
                    speed: random(0.0005, 0.002),
                    opacity: random(100, 180),
                    dotSize: random(2, 4),
                    dotSpacing: random(10, 18),
                    startTime: memoryFragments[i].startTime + 600,
                    interactive: random() > 0.7,
                    activated: false,
                    activatedTime: 0,
                    message: getRandomMemory()
                });
            }
            
            // Add some additional random connections
            for (let i = 0; i < 12; i++) {
                let startIndex = floor(random(memoryFragments.length));
                let endIndex = floor(random(memoryFragments.length));
                
                if (startIndex !== endIndex) {
                    memoryPathways.push({
                        start: startIndex,
                        end: endIndex,
                        progress: 0,
                        speed: random(0.0005, 0.0015),
                        opacity: random(80, 140),
                        dotSize: random(1.5, 3),
                        dotSpacing: random(12, 20),
                        startTime: 12000 + i * 1000,
                        interactive: random() > 0.5,
                        activated: false,
                        activatedTime: 0,
                        message: getRandomMemory()
                    });
                }
            }
            
            // Create emotional response elements (yellow)
            for (let i = 0; i < 10; i++) {
                let isCircle = random() > 0.4;
                emotionalResponse.push({
                    x: random(width * 0.15, width * 0.85),
                    y: random(height * 0.15, height * 0.85),
                    width: isCircle ? random(20, 40) : random(30, 60),
                    height: isCircle ? undefined : random(15, 30),
                    isCircle: isCircle,
                    pulseRate: random(0.001, 0.003),
                    opacity: random(130, 180),
                    startTime: 8000 + i * 1100,
                    visible: false,
                    interactive: random() > 0.3,
                    activated: false,
                    activatedTime: 0,
                    message: getRandomMemory()
                });
            }
            
            // Create bronze elements (grounding elements)
            for (let i = 0; i < 7; i++) {
                let shapeType = floor(random(3)); // 0: rectangle, 1: arc, 2: line
                groundingElements.push({
                    x: random(width * 0.2, width * 0.8),
                    y: random(height * 0.2, height * 0.8),
                    width: random(40, 80),
                    height: shapeType === 0 ? random(40, 60) : 
                             shapeType === 1 ? random(15, 30) : random(3, 8),
                    shapeType: shapeType,
                    opacity: random(150, 220),
                    startTime: 16000 + i * 1400,
                    visible: false,
                    interactive: random() > 0.4,
                    activated: false,
                    activatedTime: 0,
                    message: getRandomMemory()
                });
            }
            
            // Create 3-4 special focal points - larger interactive memory nodes
            createFocalPoints();
            
            // Initialize audio context for better mobile support
            if (getAudioContext().state !== 'running') {
                getAudioContext().resume();
            }
            
            // Initially pause animation while on landing page
            isAnimating = false;
            noLoop(); // Pause the animation until user enters
        }
        
        function getRandomMemory() {
            return memoryEchoes[floor(random(memoryEchoes.length))];
        }
        
        function createFocalPoints() {
            const numFocalPoints = 4;
            
            for (let i = 0; i < numFocalPoints; i++) {
                focalPoints.push({
                    x: random(width * 0.25, width * 0.75),
                    y: random(height * 0.25, height * 0.75),
                    size: random(40, 60),
                    opacity: 0,
                    targetOpacity: random(180, 220),
                    pulseRate: random(0.0005, 0.0015),
                    activated: false,
                    activationProgress: 0,
                    startTime: 9000 + i * 3000,
                    message: getRandomMemory(),
                    elements: []
                });
            }
            
            // Assign some memory fragments to each focal point
            // This creates clusters of memories
            for (let i = 0; i < memoryFragments.length; i++) {
                let closestFocalPoint = null;
                let closestDistance = Infinity;
                
                // Find the closest focal point
                for (let j = 0; j < focalPoints.length; j++) {
                    let d = dist(memoryFragments[i].x, memoryFragments[i].y, 
                                focalPoints[j].x, focalPoints[j].y);
                    if (d < closestDistance) {
                        closestDistance = d;
                        closestFocalPoint = j;
                    }
                }
                
                // Assign to focal point if within radius
                if (closestDistance < 150) {
                    focalPoints[closestFocalPoint].elements.push(i);
                }
            }
        }

        function createHandOutline() {
            // Create a simplified hand outline
            // Base of palm
            handOutlinePoints.push({x: 0.4, y: 0.7});
            handOutlinePoints.push({x: 0.6, y: 0.7});
            
            // Right side of hand
            handOutlinePoints.push({x: 0.62, y: 0.65});
            handOutlinePoints.push({x: 0.63, y: 0.6});
            
            // Pinky finger
            handOutlinePoints.push({x: 0.65, y: 0.55});
            handOutlinePoints.push({x: 0.67, y: 0.48});
            handOutlinePoints.push({x: 0.65, y: 0.45});
            
            // Ring finger
            handOutlinePoints.push({x: 0.61, y: 0.43});
            handOutlinePoints.push({x: 0.6, y: 0.36});
            handOutlinePoints.push({x: 0.58, y: 0.32});
            
            // Middle finger
            handOutlinePoints.push({x: 0.55, y: 0.3});
            handOutlinePoints.push({x: 0.53, y: 0.24});
            handOutlinePoints.push({x: 0.51, y: 0.22});
            
            // Index finger
            handOutlinePoints.push({x: 0.48, y: 0.25});
            handOutlinePoints.push({x: 0.45, y: 0.28});
            handOutlinePoints.push({x: 0.43, y: 0.32});
            
            // Thumb
            handOutlinePoints.push({x: 0.39, y: 0.4});
            handOutlinePoints.push({x: 0.35, y: 0.45});
            handOutlinePoints.push({x: 0.37, y: 0.52});
            
            // Left side of hand
            handOutlinePoints.push({x: 0.38, y: 0.6});
            handOutlinePoints.push({x: 0.4, y: 0.7});
            
            // Convert relative coordinates to absolute
            for (let i = 0; i < handOutlinePoints.length; i++) {
                handOutlinePoints[i].x *= width;
                handOutlinePoints[i].y *= height;
            }
        }

        function draw() {
            // Clear the canvas with a warm white background
            background(248, 247, 242);
            
            // If animating, update time position
            if (isAnimating && !isDraggingTimeline) {
                timePosition += deltaTime;
                
                // Limit to 30 seconds
                if (timePosition > 30000) {
                    timePosition = 30000;
                    
                    // Show timeline if reached end
                    if (!activatedTimeline) {
                        showTimeline();
                        activatedTimeline = true;
                    }
                }
                
                // Update timeline UI
                updateTimelineUI();
                
                previousTimePosition = timePosition;
            }

            // Draw the layers in appropriate order
            drawGroundingElements();  // First layer (bottom)
            drawHandOutline();        // Second layer (middle)
            drawMemoryFragments();    // Third layer
            drawMemoryPathways();     // Fourth layer
            drawEmotionalResponse();  // Fifth layer (top)
            drawFocalPoints();        // Interactive focal points
            
            // Update hand outline progress
            if (isAnimating) {
                handProgress = min(1, handProgress + 0.0005);
            }
            
            // Update activated elements
            updateActivatedElements();
        }
        
        function showTimeline() {
            // Show the timeline interface
            document.getElementById('timeline').style.opacity = '1';
        }
        
        function updateActivatedElements() {
            // Check any activated fragments
            for (let fragment of memoryFragments) {
                if (fragment.activated) {
                    if (millis() - fragment.activatedTime > 4000) {
                        fragment.activated = false;
                    }
                }
            }
            
            // Check any activated emotional responses
            for (let element of emotionalResponse) {
                if (element.activated) {
                    if (millis() - element.activatedTime > 4000) {
                        element.activated = false;
                    }
                }
            }
            
            // Check any activated grounding elements
            for (let element of groundingElements) {
                if (element.activated) {
                    if (millis() - element.activatedTime > 4000) {
                        element.activated = false;
                    }
                }
            }
            
            // Check any activated pathways
            for (let pathway of memoryPathways) {
                if (pathway.activated) {
                    if (millis() - pathway.activatedTime > 4000) {
                        pathway.activated = false;
                    }
                }
            }
            
            // Check activated focal points
            for (let focal of focalPoints) {
                if (focal.activated) {
                    focal.activationProgress = min(1, focal.activationProgress + 0.01);
                }
            }
            
            // If we have an active focal point but it's no longer activated
            if (activeFocalPoint !== null && !focalPoints[activeFocalPoint].activated) {
                if (focalPoints[activeFocalPoint].activationProgress > 0) {
                    focalPoints[activeFocalPoint].activationProgress = max(0, focalPoints[activeFocalPoint].activationProgress - 0.01);
                } else {
                    activeFocalPoint = null;
                    focalPointActivated = false;
                }
            }
        }
        
        function setTimePosition(time) {
            // Set the internal time position
            const previousMillis = previousTimePosition;
            const timeDiff = time - previousMillis;
            
            // Reset elements if jumping backward more than 2 seconds
            if (timeDiff < -2000) {
                resetExperience();
            }
        }
        
        function resetExperience() {
            // Reset all elements to their initial state
            for (let fragment of memoryFragments) {
                fragment.visible = timePosition > fragment.startTime;
                fragment.activated = false;
            }
            
            for (let pathway of memoryPathways) {
                pathway.progress = 0;
                pathway.activated = false;
            }
            
            for (let element of emotionalResponse) {
                element.visible = timePosition > element.startTime;
                element.activated = false;
            }
            
            for (let element of groundingElements) {
                element.visible = timePosition > element.startTime;
                element.activated = false;
            }
            
            for (let focal of focalPoints) {
                focal.opacity = 0;
                focal.activated = false;
                focal.activationProgress = 0;
            }
            
            handProgress = min(1, timePosition / 20000);
            activeFocalPoint = null;
            focalPointActivated = false;
        }

        function drawHandOutline() {
            // Only start drawing hand after initial elements appear
            if (timePosition < 6000) return;
            
            // Calculate how many points to show based on progress
            let pointsToShow = floor(handOutlinePoints.length * handProgress);
            
            if (pointsToShow < 2) return;
            
            // Draw the hand outline as a faint connecting line
            noFill();
            stroke(180, 160, 140, 50); // Very faint warm gray
            strokeWeight(1.5);
            
            beginShape();
            for (let i = 0; i < pointsToShow; i++) {
                vertex(handOutlinePoints[i].x, handOutlinePoints[i].y);
            }
            endShape();
        }

        function drawMemoryFragments() {
            // Purple elements representing memory fragments
            noStroke();
            
            for (let i = 0; i < memoryFragments.length; i++) {
                let fragment = memoryFragments[i];
                
                // Check if this element should be visible based on its timing
                if (timePosition > fragment.startTime) {
                    fragment.visible = true;
                }
                
                if (fragment.visible) {
                    // Use normal or light purple based on interaction
                    let colorToUse = fragment.activated ? colors.lightPurple : colors.purple;
                    
                    // If this fragment belongs to an active focal point, enhance it
                    if (activeFocalPoint !== null && 
                        focalPoints[activeFocalPoint].elements.includes(i) &&
                        focalPoints[activeFocalPoint].activationProgress > 0) {
                        
                        // Scale the size based on activation progress
                        let scaleFactor = 1 + focalPoints[activeFocalPoint].activationProgress * 0.5;
                        
                        // Draw with enhanced appearance
                        fill(colorToUse[0], colorToUse[1], colorToUse[2], 
                             fragment.opacity + 40 * focalPoints[activeFocalPoint].activationProgress);
                        ellipse(fragment.x, fragment.y, fragment.size * scaleFactor);
                        
                        // Add glow for activated fragments
                        noFill();
                        stroke(colorToUse[0], colorToUse[1], colorToUse[2], 
                               80 * focalPoints[activeFocalPoint].activationProgress);
                        strokeWeight(1);
                        ellipse(fragment.x, fragment.y, fragment.size * scaleFactor + 5);
                        noStroke();
                        
                    } else {
                        // Normal drawing
                        fill(colorToUse[0], colorToUse[1], colorToUse[2], fragment.opacity);
                        ellipse(fragment.x, fragment.y, fragment.size);
                        
                        // Add subtle pulse for interactive elements
                        if (fragment.interactive && !fragment.activated) {
                            let pulseSize = fragment.size + sin(millis() * fragment.pulseRate) * 3;
                            noFill();
                            stroke(colorToUse[0], colorToUse[1], colorToUse[2], 40);
                            strokeWeight(0.5);
                            ellipse(fragment.x, fragment.y, pulseSize);
                            noStroke();
                        }
                        
                        // Add highlight for activated fragments
                        if (fragment.activated) {
                            noFill();
                            stroke(colorToUse[0], colorToUse[1], colorToUse[2], 100);
                            strokeWeight(1.5);
                            ellipse(fragment.x, fragment.y, fragment.size + 8);
                            noStroke();
                        }
                    }
                }
            }
        }

        function drawMemoryPathways() {
            // Dotted pathways connecting memory fragments
            for (let pathway of memoryPathways) {
                // Only start drawing after the delay
                if (timePosition > pathway.startTime) {
                    // Update progress if animating
                    if (isAnimating) {
                        pathway.progress = min(1, pathway.progress + pathway.speed);
                    }
                    
                    // Get start and end points
                    let start = memoryFragments[pathway.start];
                    let end = memoryFragments[pathway.end];
                    
                    // Only draw if both fragments are visible
                    if (start.visible && end.visible) {
                        // Calculate color based on activation
                        let baseColor = pathway.activated ? colors.lightPurple : colors.purple;
                        let pathOpacity = pathway.activated ? pathway.opacity * 1.5 : pathway.opacity;
                        let pathSize = pathway.activated ? pathway.dotSize * 1.3 : pathway.dotSize;
                        
                        // Draw dotted line
                        let distance = dist(start.x, start.y, end.x, end.y);
                        let numDots = floor(distance / pathway.dotSpacing);
                        
                        // Draw dots along the path
                        for (let i = 0; i <= numDots * pathway.progress; i++) {
                            let t = i / numDots;
                            let x = lerp(start.x, end.x, t);
                            let y = lerp(start.y, end.y, t);
                            
                            // Draw dot
                            noStroke();
                            fill(baseColor[0], baseColor[1], baseColor[2], pathOpacity);
                            ellipse(x, y, pathSize);
                        }
                        
                        // Add highlight for interactive pathways
                        if (pathway.interactive && !pathway.activated) {
                            let midX = (start.x + end.x) / 2;
                            let midY = (start.y + end.y) / 2;
                            
                            noFill();
                            stroke(baseColor[0], baseColor[1], baseColor[2], 40);
                            strokeWeight(1);
                            ellipse(midX, midY, 15 + sin(millis() * 0.003) * 3);
                            noStroke();
                        }
                        
                        // Add highlight for activated pathways
                        if (pathway.activated) {
                            let midX = (start.x + end.x) / 2;
                            let midY = (start.y + end.y) / 2;
                            
                            noFill();
                            stroke(baseColor[0], baseColor[1], baseColor[2], 120);
                            strokeWeight(1.5);
                            ellipse(midX, midY, 20);
                            noStroke();
                        }
                    }
                }
            }
        }

        function drawEmotionalResponse() {
            // Yellow elements for emotional response
            noStroke();
            
            for (let element of emotionalResponse) {
                // Check if this element should be visible based on its timing
                if (timePosition > element.startTime) {
                    element.visible = true;
                }
                
                if (element.visible) {
                    // Calculate pulsing for the element
                    let pulseAmount = sin(millis() * element.pulseRate);
                    let scaleMultiplier = 1 + pulseAmount * 0.2;
                    
                    // Enhanced appearance for activated elements
                    if (element.activated) {
                        // Draw glow
                        noFill();
                        stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 100);
                        strokeWeight(2);
                        if (element.isCircle) {
                            ellipse(element.x, element.y, element.width * scaleMultiplier + 10);
                        } else {
                            rectMode(CENTER);
                            rect(element.x, element.y, 
                                element.width * scaleMultiplier + 10, 
                                element.height * scaleMultiplier + 10, 
                                (element.height * scaleMultiplier + 10) / 2);
                        }
                        noStroke();
                    }
                    
                    // Draw main shape
                    fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                         element.opacity * (0.7 + pulseAmount * 0.3));
                    
                    if (element.isCircle) {
                        ellipse(element.x, element.y, element.width * scaleMultiplier);
                    } else {
                        // Pill shape
                        rectMode(CENTER);
                        rect(element.x, element.y, 
                             element.width * scaleMultiplier, 
                             element.height * scaleMultiplier, 
                             element.height * scaleMultiplier / 2); // Rounded corners
                    }
                    
                    // Add subtle pulse for interactive elements
                    if (element.interactive && !element.activated) {
                        noFill();
                        stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 40);
                        strokeWeight(1);
                        if (element.isCircle) {
                            ellipse(element.x, element.y, element.width * scaleMultiplier + 15 + sin(millis() * 0.002) * 5);
                        } else {
                            rectMode(CENTER);
                            rect(element.x, element.y, 
                                element.width * scaleMultiplier + 15 + sin(millis() * 0.002) * 5, 
                                element.height * scaleMultiplier + 15 + sin(millis() * 0.002) * 5, 
                                (element.height * scaleMultiplier + 15) / 2);
                        }
                        noStroke();
                    }
                }
            }
        }

        function drawGroundingElements() {
            // Bronze elements representing grounding aspects
            noStroke();
            
            for (let element of groundingElements) {
                // Check if this element should be visible based on its timing
                if (timePosition > element.startTime) {
                    element.visible = true;
                }
                
                if (element.visible) {
                    // Add glow for activated elements
                    if (element.activated) {
                        noFill();
                        stroke(colors.bronze[0], colors.bronze[1], colors.bronze[2], 100);
                        strokeWeight(2);
                        
                        if (element.shapeType === 0) {
                            rectMode(CENTER);
                            rect(element.x, element.y, element.width + 10, element.height + 10, 8);
                        } else if (element.shapeType === 1) {
                            arc(element.x, element.y, element.width + 10, (element.height + 5) * 2, PI, TWO_PI, CHORD);
                        } else {
                            rectMode(CENTER);
                            rect(element.x, element.y, element.width + 10, element.height + 4);
                        }
                        
                        noStroke();
                    }
                    
                    // Draw main element
                    fill(colors.bronze[0], colors.bronze[1], colors.bronze[2], element.opacity);
                    
                    if (element.shapeType === 0) {
                        // Rectangle - structured memory foundation
                        rectMode(CENTER);
                        rect(element.x, element.y, element.width, element.height, 5);
                    } else if (element.shapeType === 1) {
                        // Arc / semicircle - embracing memory
                        arc(element.x, element.y, element.width, element.height * 2, PI, TWO_PI, CHORD);
                    } else {
                        // Line - connection between past and present
                        rectMode(CENTER);
                        rect(element.x, element.y, element.width, element.height);
                    }
                    
                    // Add subtle pulse for interactive elements
                    if (element.interactive && !element.activated) {
                        noFill();
                        stroke(colors.bronze[0], colors.bronze[1], colors.bronze[2], 40);
                        strokeWeight(1);
                        
                        if (element.shapeType === 0) {
                            rectMode(CENTER);
                            rect(element.x, element.y, 
                                element.width + 15 + sin(millis() * 0.002) * 5, 
                                element.height + 15 + sin(millis() * 0.002) * 5, 8);
                        } else if (element.shapeType === 1) {
                            arc(element.x, element.y, 
                                element.width + 15 + sin(millis() * 0.002) * 5, 
                                (element.height + 7) * 2, PI, TWO_PI, CHORD);
                        } else {
                            rectMode(CENTER);
                            rect(element.x, element.y, 
                                element.width + 20 + sin(millis() * 0.002) * 5, 
                                element.height + 5);
                        }
                        
                        noStroke();
                    }
                }
            }
        }
        
        function drawFocalPoints() {
            // Only draw focal points after they should appear
            for (let i = 0; i < focalPoints.length; i++) {
                let focal = focalPoints[i];
                
                // Check timing
                if (timePosition > focal.startTime) {
                    // Fade in opacity
                    if (focal.opacity < focal.targetOpacity) {
                        focal.opacity = min(focal.targetOpacity, focal.opacity + 0.5);
                    }
                    
                    // Calculate pulse effect
                    let pulseAmount = sin(millis() * focal.pulseRate);
                    let pulseSize = focal.size + pulseAmount * 10;
                    
                    // Draw outer glow for active focal points
                    if (i === activeFocalPoint && focal.activationProgress > 0) {
                        // Radiate outward
                        for (let j = 0; j < 3; j++) {
                            let expandedSize = pulseSize + j * 20 * focal.activationProgress;
                            let glowOpacity = (100 - j * 30) * focal.activationProgress;
                            
                            noFill();
                            stroke(colors.lightPurple[0], colors.lightPurple[1], colors.lightPurple[2], glowOpacity);
                            strokeWeight(2 - j * 0.5);
                            ellipse(focal.x, focal.y, expandedSize);
                        }
                    }
                    
                    // Draw main focal point
                    noFill();
                    stroke(colors.purple[0], colors.purple[1], colors.purple[2], focal.opacity);
                    strokeWeight(2);
                    ellipse(focal.x, focal.y, pulseSize);
                    
                    // Draw center
                    fill(colors.purple[0], colors.purple[1], colors.purple[2], focal.opacity + 20);
                    noStroke();
                    ellipse(focal.x, focal.y, pulseSize * 0.3);
                    
                    // Add interactive hint
                    if (!focal.activated) {
                        fill(colors.lightPurple[0], colors.lightPurple[1], colors.lightPurple[2], 
                            70 + 30 * sin(millis() * 0.004));
                        textAlign(CENTER, CENTER);
                        textSize(10);
                        text("tap", focal.x, focal.y);
                    }
                }
            }
        }
        
        function showMemoryEcho(message, x, y) {
            const echo = document.getElementById('memory-echo');
            echo.innerHTML = message;
            
            // Position near the element but within screen bounds
            let posX = x;
            let posY = y - 60;
            
            // Adjust if would go off screen
            if (posX < 20) posX = 20;
            if (posX > window.innerWidth - 270) posX = window.innerWidth - 270;
            if (posY < 20) posY = 20;
            if (posY > window.innerHeight - 100) posY = window.innerHeight - 100;
            
            echo.style.left = posX + 'px';
            echo.style.top = posY + 'px';
            echo.style.transform = 'translateY(0)';
            echo.style.opacity = '1';
            
            // Hide after 4 seconds
            setTimeout(() => {
                echo.style.opacity = '0';
                echo.style.transform = 'translateY(20px)';
            }, 4000);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            
            // Recalculate hand outline points for new dimensions
            for (let i = 0; i < handOutlinePoints.length; i++) {
                handOutlinePoints[i].x = (handOutlinePoints[i].x / width) * windowWidth;
                handOutlinePoints[i].y = (handOutlinePoints[i].y / height) * windowHeight;
            }
            
            // Reposition other elements
            for (let fragment of memoryFragments) {
                fragment.x = (fragment.x / width) * windowWidth;
                fragment.y = (fragment.y / height) * windowHeight;
            }
            
            for (let element of emotionalResponse) {
                element.x = (element.x / width) * windowWidth;
                element.y = (element.y / height) * windowHeight;
            }
            
            for (let element of groundingElements) {
                element.x = (element.x / width) * windowWidth;
                element.y = (element.y / height) * windowHeight;
            }
            
            for (let focal of focalPoints) {
                focal.x = (focal.x / width) * windowWidth;
                focal.y = (focal.y / height) * windowHeight;
            }
        }
        
        function mousePressed() {
            // Only process clicks after landing page has disappeared
            if (document.getElementById('landing-overlay').style.display === 'none') {
                
                // Check for interactions with focal points first
                for (let i = 0; i < focalPoints.length; i++) {
                    let focal = focalPoints[i];
                    
                    if (timePosition > focal.startTime) {
                        let d = dist(mouseX, mouseY, focal.x, focal.y);
                        
                        if (d < focal.size / 2) {
                            // Toggle focal point activation
                            focal.activated = !focal.activated;
                            
                            if (focal.activated) {
                                // Set as active focal point
                                activeFocalPoint = i;
                                focalPointActivated = true;
                                
                                // Show memory echo
                                showMemoryEcho(focal.message, focal.x, focal.y);
                                
                                // Play special sound if enabled
                                if (soundEnabled && nostalgiaSound) {
                                    // Could add special sound effect here
                                }
                            } else {
                                // Deactivate
                                activeFocalPoint = null;
                                focalPointActivated = false;
                            }
                            
                            return false;
                        }
                    }
                }
                
                // Check for interactions with memory fragments
                for (let fragment of memoryFragments) {
                    if (fragment.visible && fragment.interactive) {
                        let d = dist(mouseX, mouseY, fragment.x, fragment.y);
                        
                        if (d < fragment.size) {
                            // Toggle activation
                            fragment.activated = !fragment.activated;
                            fragment.activatedTime = millis();
                            
                            // Show memory echo with random memory
                            if (fragment.activated) {
                                showMemoryEcho(getRandomMemory(), fragment.x, fragment.y);
                            }
                            
                            return false;
                        }
                    }
                }
                
                // Check for interactions with pathways
                for (let pathway of memoryPathways) {
                    if (timePosition > pathway.startTime && pathway.interactive) {
                        let start = memoryFragments[pathway.start];
                        let end = memoryFragments[pathway.end];
                        
                        if (start.visible && end.visible) {
                            let midX = (start.x + end.x) / 2;
                            let midY = (start.y + end.y) / 2;
                            
                            let d = dist(mouseX, mouseY, midX, midY);
                            
                            if (d < 20) {
                                // Toggle activation
                                pathway.activated = !pathway.activated;
                                pathway.activatedTime = millis();
                                
                                // Show memory echo
                                if (pathway.activated) {
                                    showMemoryEcho(pathway.message, midX, midY);
                                }
                                
                                return false;
                            }
                        }
                    }
                }
                
                // Check for interactions with emotional response elements
                for (let element of emotionalResponse) {
                    if (element.visible && element.interactive) {
                        let hitArea = element.isCircle ? element.width / 2 : 
                                     Math.max(element.width, element.height) / 2;
                        
                        let d = dist(mouseX, mouseY, element.x, element.y);
                        
                        if (d < hitArea) {
                            // Toggle activation
                            element.activated = !element.activated;
                            element.activatedTime = millis();
                            
                            // Show memory echo
                            if (element.activated) {
                                showMemoryEcho(element.message, element.x, element.y);
                            }
                            
                            return false;
                        }
                    }
                }
                
                // Check for interactions with grounding elements
                for (let element of groundingElements) {
                    if (element.visible && element.interactive) {
                        let hitArea = Math.max(element.width, element.height) / 2;
                        
                        let d = dist(mouseX, mouseY, element.x, element.y);
                        
                        if (d < hitArea) {
                            // Toggle activation
                            element.activated = !element.activated;
                            element.activatedTime = millis();
                            
                            // Show memory echo
                            if (element.activated) {
                                showMemoryEcho(element.message, element.x, element.y);
                            }
                            
                            return false;
                        }
                    }
                }
                
                // If no element was clicked, toggle pause
                isAnimating = !isAnimating;
                
                // Update sound based on animation state
                if (!isAnimating && soundEnabled && soundLoaded && nostalgiaSound.isPlaying()) {
                    nostalgiaSound.setVolume(0.3, 1);
                } else if (isAnimating && soundEnabled && soundLoaded) {
                    nostalgiaSound.setVolume(0.6, 1);
                }
            }
            
            return false;
        }
        
        // Support touch events
        function touchStarted() {
            // Initialize audio context for iOS
            if (getAudioContext().state !== 'running') {
                getAudioContext().resume();
            }
            
            return mousePressed();
        }
        
        // Support for long press gesture
        let touchStartTime = 0;
        let touchTimer = null;
        let touchX = 0;
        let touchY = 0;
        
        function touchStarted(e) {
            // Get the touch position
            touchX = touches[0].x;
            touchY = touches[0].y;
            
            // Record start time
            touchStartTime = millis();
            
            // Clear any existing timer
            if (touchTimer) clearTimeout(touchTimer);
            
            // Set new timer
            touchTimer = setTimeout(handleLongPress, 1000);
            
            // Resume audio context for iOS
            if (getAudioContext().state !== 'running') {
                getAudioContext().resume();
            }
            
            return mousePressed();
        }
        
        function touchEnded() {
            // Clear the long press timer
            if (touchTimer) {
                clearTimeout(touchTimer);
                touchTimer = null;
            }
        }
        
        function touchMoved() {
            // Clear the long press timer if touch moves too much
            if (touchTimer && dist(touchX, touchY, touches[0].x, touches[0].y) > 10) {
                clearTimeout(touchTimer);
                touchTimer = null;
            }
        }
        
        function handleLongPress() {
            // Handle special actions for long press
            
            // Show timeline if not already visible
            if (document.getElementById('timeline').style.opacity === '0') {
                document.getElementById('timeline').style.opacity = '1';
                activatedTimeline = true;
            }
            
            // Look for focal points near the long press
            let nearestFocal = null;
            let nearestDist = Infinity;
            
            for (let i = 0; i < focalPoints.length; i++) {
                let focal = focalPoints[i];
                if (timePosition > focal.startTime) {
                    let d = dist(touchX, touchY, focal.x, focal.y);
                    if (d < 100 && d < nearestDist) {
                        nearestDist = d;
                        nearestFocal = i;
                    }
                }
            }
            
            // If we found a nearby focal point, highlight all its connected elements
            if (nearestFocal !== null) {
                // Activate the focal point
                focalPoints[nearestFocal].activated = true;
                activeFocalPoint = nearestFocal;
                focalPointActivated = true;
                
                // Show memory echo
                showMemoryEcho(focalPoints[nearestFocal].message, 
                              focalPoints[nearestFocal].x, 
                              focalPoints[nearestFocal].y - 30);
                
                // Special effect for long press on focal points
                for (let i of focalPoints[nearestFocal].elements) {
                    // Activate all memory fragments in this cluster
                    memoryFragments[i].activated = true;
                    memoryFragments[i].activatedTime = millis();
                }
            }
            
            // Clear the timer
            touchTimer = null;
        }
    </script>
</body>
</html>
