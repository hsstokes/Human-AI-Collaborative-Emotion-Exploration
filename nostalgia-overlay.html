<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Nostalgia - Emotional Experience</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f5f5f7;
            font-family: 'Roboto Mono', monospace;
            -webkit-text-size-adjust: 100%;
            touch-action: none;
        }
        
        /* Landing screen that appears first */
        #landing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(245, 245, 247, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            box-sizing: border-box;
            padding: 20px;
            transition: opacity 1s ease-in-out;
        }
        
        .landing-title {
            font-size: 24px;
            font-weight: 500;
            margin-bottom: 40px;
            text-align: center;
            letter-spacing: 1px;
        }
        
        .emotion-name {
            font-size: 36px;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #50377E; /* Purple for nostalgia */
        }
        
        .emotion-description {
            font-size: 14px;
            line-height: 1.4;
            max-width: 600px;
            text-align: center;
            margin-bottom: 80px;
            opacity: 0.8;
        }
        
        .start-button {
            padding: 15px 35px;
            background-color: #333;
            color: #fff;
            border: none;
            border-radius: 30px;
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .start-button:active {
            transform: scale(0.98);
        }
        
        /* Canvas for the animation */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
    </style>
</head>
<body>
    <!-- Initial landing overlay -->
    <div id="landing-overlay">
        <h1 class="landing-title">Emotional Collage Experience</h1>
        <h2 class="emotion-name" id="emotion-title">NOSTALGIA</h2>
        <p class="emotion-description" id="emotion-description">
            A reflection on the bittersweet remembrance of things past, the emotional texture of memory and temporal distance.
            <br><b>Analysis by Claude</b>
        </p>
        <button class="start-button" id="start-experience">Begin Experience</button>
    </div>
    
    <script>
        let isAnimating = true;
        let soundEnabled = true;
        let nostalgiaSound;
        let soundLoaded = false;
        
        // Color palette for Nostalgia
        const colors = {
            purple: [200, 177, 230],  // Light purple - Memory fragments
            yellow: [255, 216, 0],    // Yellow - Emotional response
            bronze: [205, 127, 50]    // Bronze - Grounding elements
        };
        
        // Elements for each conceptual layer
        let memoryFragments = [];     // Purple elements - fragments of memory
        let emotionalResponse = [];   // Yellow elements - emotional reaction to memories
        let groundingElements = [];   // Bronze elements - anchoring elements
        
        // Memory pathways that connect elements
        let memoryPathways = [];
        
        // Hand outline coordinates (will gradually appear)
        let handOutlinePoints = [];
        let handProgress = 0;
        
        // Setup for landing page interaction
        document.getElementById('start-experience').addEventListener('click', function() {
            // Fade out landing overlay
            document.getElementById('landing-overlay').style.opacity = '0';
            
            // After fading out, remove from DOM
            setTimeout(() => {
                document.getElementById('landing-overlay').style.display = 'none';
                
                // Start animation
                isAnimating = true;
                loop();
                
                // Start sound if enabled
                if (soundEnabled && soundLoaded) {
                    try {
                        nostalgiaSound.loop();
                        nostalgiaSound.setVolume(0);
                        nostalgiaSound.setVolume(0.6, 2); // Fade in over 2 seconds
                    } catch(e) {
                        console.error("Error playing sound:", e);
                    }
                }
            }, 1000);
        });
        
        function preload() {
            // Pre-load sound
            soundLoaded = false;
            nostalgiaSound = loadSound('nostalgia_soundscape.mp3', 
                function() {
                    console.log("Sound loaded successfully");
                    soundLoaded = true;
                },
                function(err) {
                    console.error("Error loading sound:", err);
                    soundEnabled = false;
                }
            );
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            
            // Define hand outline points - a simplified hand silhouette
            createHandOutline();
            
            // Create memory fragments (purple elements)
            for (let i = 0; i < 28; i++) {
                memoryFragments.push({
                    x: random(width * 0.1, width * 0.9),
                    y: random(height * 0.1, height * 0.9),
                    size: random(5, 15),
                    opacity: random(150, 230),
                    startTime: i * 500,
                    visible: false
                });
            }
            
            // Create memory pathways connecting memory fragments
            for (let i = 0; i < memoryFragments.length - 1; i++) {
                memoryPathways.push({
                    start: i,
                    end: (i + 1) % memoryFragments.length,
                    progress: 0,
                    speed: random(0.0005, 0.002),
                    opacity: random(100, 180),
                    dotSize: random(2, 4),
                    dotSpacing: random(10, 18),
                    startTime: memoryFragments[i].startTime + 600
                });
            }
            
            // Add some additional random connections
            for (let i = 0; i < 12; i++) {
                let startIndex = floor(random(memoryFragments.length));
                let endIndex = floor(random(memoryFragments.length));
                
                if (startIndex !== endIndex) {
                    memoryPathways.push({
                        start: startIndex,
                        end: endIndex,
                        progress: 0,
                        speed: random(0.0005, 0.0015),
                        opacity: random(80, 140),
                        dotSize: random(1.5, 3),
                        dotSpacing: random(12, 20),
                        startTime: 12000 + i * 1000
                    });
                }
            }
            
            // Create emotional response elements (yellow)
            for (let i = 0; i < 10; i++) {
                let isCircle = random() > 0.4;
                emotionalResponse.push({
                    x: random(width * 0.15, width * 0.85),
                    y: random(height * 0.15, height * 0.85),
                    width: isCircle ? random(20, 40) : random(30, 60),
                    height: isCircle ? undefined : random(15, 30),
                    isCircle: isCircle,
                    pulseRate: random(0.001, 0.003),
                    opacity: random(130, 180),
                    startTime: 8000 + i * 1100,
                    visible: false
                });
            }
            
            // Create bronze elements (grounding elements)
            for (let i = 0; i < 7; i++) {
                let shapeType = floor(random(3)); // 0: rectangle, 1: arc, 2: line
                groundingElements.push({
                    x: random(width * 0.2, width * 0.8),
                    y: random(height * 0.2, height * 0.8),
                    width: random(40, 80),
                    height: shapeType === 0 ? random(40, 60) : 
                             shapeType === 1 ? random(15, 30) : random(3, 8),
                    shapeType: shapeType,
                    opacity: random(150, 220),
                    startTime: 16000 + i * 1400,
                    visible: false
                });
            }
            
            // Initialize audio context for better mobile support
            if (getAudioContext().state !== 'running') {
                getAudioContext().resume();
            }
            
            // Initially pause animation while on landing page
            isAnimating = false;
            noLoop(); // Pause the animation until user enters
        }

        function createHandOutline() {
            // Create a simplified hand outline
            // Base of palm
            handOutlinePoints.push({x: 0.4, y: 0.7});
            handOutlinePoints.push({x: 0.6, y: 0.7});
            
            // Right side of hand
            handOutlinePoints.push({x: 0.62, y: 0.65});
            handOutlinePoints.push({x: 0.63, y: 0.6});
            
            // Pinky finger
            handOutlinePoints.push({x: 0.65, y: 0.55});
            handOutlinePoints.push({x: 0.67, y: 0.48});
            handOutlinePoints.push({x: 0.65, y: 0.45});
            
            // Ring finger
            handOutlinePoints.push({x: 0.61, y: 0.43});
            handOutlinePoints.push({x: 0.6, y: 0.36});
            handOutlinePoints.push({x: 0.58, y: 0.32});
            
            // Middle finger
            handOutlinePoints.push({x: 0.55, y: 0.3});
            handOutlinePoints.push({x: 0.53, y: 0.24});
            handOutlinePoints.push({x: 0.51, y: 0.22});
            
            // Index finger
            handOutlinePoints.push({x: 0.48, y: 0.25});
            handOutlinePoints.push({x: 0.45, y: 0.28});
            handOutlinePoints.push({x: 0.43, y: 0.32});
            
            // Thumb
            handOutlinePoints.push({x: 0.39, y: 0.4});
            handOutlinePoints.push({x: 0.35, y: 0.45});
            handOutlinePoints.push({x: 0.37, y: 0.52});
            
            // Left side of hand
            handOutlinePoints.push({x: 0.38, y: 0.6});
            handOutlinePoints.push({x: 0.4, y: 0.7});
            
            // Convert relative coordinates to absolute
            for (let i = 0; i < handOutlinePoints.length; i++) {
                handOutlinePoints[i].x *= width;
                handOutlinePoints[i].y *= height;
            }
        }

        function draw() {
            // Clear the canvas with a warm white background
            background(248, 247, 242);

            // Draw the layers in appropriate order
            drawGroundingElements();  // First layer (bottom)
            drawHandOutline();        // Second layer (middle)
            drawMemoryFragments();    // Third layer
            drawMemoryPathways();     // Fourth layer
            drawEmotionalResponse();  // Fifth layer (top)
            
            // Update hand outline progress
            if (isAnimating) {
                handProgress = min(1, handProgress + 0.0005);
            }
        }

        function drawHandOutline() {
            // Only start drawing hand after initial elements appear
            if (millis() < 6000) return;
            
            // Calculate how many points to show based on progress
            let pointsToShow = floor(handOutlinePoints.length * handProgress);
            
            if (pointsToShow < 2) return;
            
            // Draw the hand outline as a faint connecting line
            noFill();
            stroke(180, 160, 140, 50); // Very faint warm gray
            strokeWeight(1.5);
            
            beginShape();
            for (let i = 0; i < pointsToShow; i++) {
                vertex(handOutlinePoints[i].x, handOutlinePoints[i].y);
            }
            endShape();
        }

        function drawMemoryFragments() {
            // Purple elements representing memory fragments
            noStroke();
            
            for (let i = 0; i < memoryFragments.length; i++) {
                let fragment = memoryFragments[i];
                
                // Check if this element should be visible based on its timing
                if (millis() > fragment.startTime) {
                    fragment.visible = true;
                }
                
                if (fragment.visible) {
                    fill(colors.purple[0], colors.purple[1], colors.purple[2], fragment.opacity);
                    ellipse(fragment.x, fragment.y, fragment.size);
                }
            }
        }

        function drawMemoryPathways() {
            // Dotted pathways connecting memory fragments
            for (let pathway of memoryPathways) {
                // Only start drawing after the delay
                if (millis() > pathway.startTime) {
                    // Update progress if animating
                    if (isAnimating) {
                        pathway.progress = min(1, pathway.progress + pathway.speed);
                    }
                    
                    // Get start and end points
                    let start = memoryFragments[pathway.start];
                    let end = memoryFragments[pathway.end];
                    
                    // Only draw if both fragments are visible
                    if (start.visible && end.visible) {
                        // Draw dotted line
                        let distance = dist(start.x, start.y, end.x, end.y);
                        let numDots = floor(distance / pathway.dotSpacing);
                        
                        // Draw dots along the path
                        for (let i = 0; i <= numDots * pathway.progress; i++) {
                            let t = i / numDots;
                            let x = lerp(start.x, end.x, t);
                            let y = lerp(start.y, end.y, t);
                            
                            // Draw dot
                            noStroke();
                            fill(colors.purple[0], colors.purple[1], colors.purple[2], pathway.opacity);
                            ellipse(x, y, pathway.dotSize);
                        }
                    }
                }
            }
        }

        function drawEmotionalResponse() {
            // Yellow elements for emotional response
            noStroke();
            
            for (let element of emotionalResponse) {
                // Check if this element should be visible based on its timing
                if (millis() > element.startTime) {
                    element.visible = true;
                }
                
                if (element.visible) {
                    // Calculate pulsing for the element
                    let pulseAmount = sin(millis() * element.pulseRate);
                    let scaleMultiplier = 1 + pulseAmount * 0.2;
                    
                    fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], element.opacity * (0.7 + pulseAmount * 0.3));
                    
                    if (element.isCircle) {
                        ellipse(element.x, element.y, element.width * scaleMultiplier);
                    } else {
                        // Pill shape
                        rectMode(CENTER);
                        rect(element.x, element.y, 
                             element.width * scaleMultiplier, 
                             element.height * scaleMultiplier, 
                             element.height * scaleMultiplier / 2); // Rounded corners
                    }
                }
            }
        }

        function drawGroundingElements() {
            // Bronze elements representing grounding aspects
            noStroke();
            
            for (let element of groundingElements) {
                // Check if this element should be visible based on its timing
                if (millis() > element.startTime) {
                    element.visible = true;
                }
                
                if (element.visible) {
                    fill(colors.bronze[0], colors.bronze[1], colors.bronze[2], element.opacity);
                    
                    if (element.shapeType === 0) {
                        // Rectangle - structured memory foundation
                        rectMode(CENTER);
                        rect(element.x, element.y, element.width, element.height, 5);
                    } else if (element.shapeType === 1) {
                        // Arc / semicircle - embracing memory
                        arc(element.x, element.y, element.width, element.height * 2, PI, TWO_PI, CHORD);
                    } else {
                        // Line - connection between past and present
                        rectMode(CENTER);
                        rect(element.x, element.y, element.width, element.height);
                    }
                }
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            
            // Recalculate hand outline points for new dimensions
            for (let i = 0; i < handOutlinePoints.length; i++) {
                handOutlinePoints[i].x = (handOutlinePoints[i].x / width) * windowWidth;
                handOutlinePoints[i].y = (handOutlinePoints[i].y / height) * windowHeight;
            }
        }
        
        function mousePressed() {
            // Toggle animation state when canvas is clicked (after landing page)
            if (document.getElementById('landing-overlay').style.display === 'none') {
                isAnimating = !isAnimating;
                
                // Handle sound based on animation state
                if (!isAnimating && soundEnabled && soundLoaded && nostalgiaSound.isPlaying()) {
                    nostalgiaSound.setVolume(0, 1);
                    setTimeout(() => {
                        nostalgiaSound.pause();
                    }, 1000);
                } else if (isAnimating && soundEnabled && soundLoaded && !nostalgiaSound.isPlaying()) {
                    nostalgiaSound.loop();
                    nostalgiaSound.setVolume(0);
                    nostalgiaSound.setVolume(0.6, 1);
                }
                
                return false;
            }
        }
        
        // Support touch events
        function touchStarted() {
            // Initialize audio context for iOS
            if (getAudioContext().state !== 'running') {
                getAudioContext().resume();
            }
            
            return mousePressed();
        }
    </script>
</body>
</html>
